<?xml version="1.0" encoding="UTF-8"?>
<rules>
  <rule>
    <key>C0102</key>
    <name><![CDATA[黑名单名称]]></name>
    <configKey>C0102</configKey>
    <description>
      <![CDATA[当名称在黑名单（未经授权的名称）中时使用。
               <p>Pylint可以帮助执行编码准则，以阻止将某些名称用于变量，函数等。
			   这些名称是使用bad-names选项指定的。只要名称在使用bad-names选项定
			   义的名称列表中，就会出现此消息。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0103</key>
    <name><![CDATA[无效名称]]></name>
    <configKey>C0103</configKey>
    <description>
      <![CDATA[当名称不符合其类型（常量、变量、类……）相关的命名规则时使用。
      <p>不建议使用此规则，可使用 {rule:python:S116}，{rule:python:S117}，{rule:python:S101}，
      {rule:python:S100}，{rule:python:S1542}，{rule:python:S1578} 来代替。</p>
	  ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0111</key>
    <name><![CDATA[缺少文档字符串]]></name>
    <configKey>C0111</configKey>
    <description>
      <![CDATA[当模块，函数，类或方法没有文档字符串时使用。 诸如__init__之类的一些特殊方法不需要使用文档字符串。
      <p>不建议使用此规则，可使用 {rule:python:S1720} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0112</key>
    <name><![CDATA[空文档字符串]]></name>
    <configKey>C0112</configKey>
    <description>
      <![CDATA[当模块，函数，类或方法的文档字符串为空时使用（也许是太过简洁 ;）。
      <p>不建议使用此规则，可使用 {rule:python:S1720} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0113</key>
    <name><![CDATA[无用的否定]]></name>
    <configKey>C0113</configKey>
    <description>
      <![CDATA[当布尔表达式包含不需要的否定时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <!-- C0121 used to be mapped to missing-module-attribute (deleted in pylint 1.5.0) -->
  <rule>
    <key>C0121</key>
    <name><![CDATA[与单例比较]]></name>
    <configKey>C0121</configKey>
    <description>
      <![CDATA[当表达式与 True，False 或 None 等单例值进行比较时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0122</key>
    <name><![CDATA[比较时常数位置错误]]></name>
    <configKey>C0122</configKey>
    <description>
      <![CDATA[当常量位于比较表达式的左侧时使用。将其放置在比较表达式的右侧会更加清楚。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0123</key>
    <name><![CDATA[在类型检查时使用 type() 代替了 isinstance()。]]></name>
    <configKey>C0123</configKey>
    <description>
      <![CDATA[当Python中执行显式类型检查的惯用方式是使用isinstance(x，Y)而不是type(x)== Y，type(x)为Y。尽管在某些特殊情况下，它们会给出不同的结果。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0200</key>
    <name><![CDATA[考虑使用枚举而不是使用range和len进行迭代]]></name>
    <configKey>C0200</configKey>
    <description>
      <![CDATA[遇到range和len进行迭代的代码时发出。可以通过使用枚举内置简化此类代码。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0201</key>
    <name><![CDATA[考虑直接迭代字典，而不是调用 .keys()]]></name>
    <configKey>C0201</configKey>
    <description>
      <![CDATA[通过 .keys()方法迭代字典时发出。只需迭代字典本身就足够了，如“for key in dictionary”。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0202</key>
    <name><![CDATA[类方法应将 “cls” 作为第一个参数]]></name>
    <configKey>C0202</configKey>
    <description>
      <![CDATA[当类方法的第一个参数的名称与valid-classmethod-first-arg选项中指定的值（默认值为 “ cls” ）不同时使用，建议使用该参数，与常规实例方法轻松区分开。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0203</key>
    <name><![CDATA[Metaclass方法应将 “ mcs” 作为第一个参数]]></name>
    <configKey>C0203</configKey>
    <description>
      <![CDATA[当metaclass方法的第一个参数的名称与valid-classmethod-first-arg选项中指定的值（默认值为 “cls” ）不同时使用，建议使用该参数，与常规实例方法轻松区分开。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0204</key>
    <name><![CDATA[Metaclass类方法的第一个参数]]></name>
    <configKey>C0204</configKey>
    <description>
      <![CDATA[当metaclass类方法的第一个参数的名称与valid-metaclass-classmethod-first-arg选项中指定的值（默认为 “mcs” ）不同时使用，建议使用此参数，与常规实例方法轻松区分开。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0205</key>
    <name><![CDATA[类 __slots__ 应该是非字符串可迭代的]]></name>
    <configKey>C0205</configKey>
    <description>
      <![CDATA[当类 __slots__ 是简单字符串而不是可迭代字符串时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0301</key>
    <name><![CDATA[行太长]]></name>
    <configKey>C0301</configKey>
    <description>
      <![CDATA[当一行之中超过指定字符数时使用。
      <p>不建议使用此规则，可使用 {rule:python:LineLength} 来代替。</p>]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0302</key>
    <name><![CDATA[块中的行数太多]]></name>
    <configKey>C0302</configKey>
    <description>
      <![CDATA[当块中行数过多时使用，降低了可读性。
      <p>不建议使用此规则，可使用 {rule:python:S104} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0303</key>
    <name><![CDATA[尾随空格]]></name>
    <configKey>C0303</configKey>
    <description>
      <![CDATA[当行尾和换行符之间有空格时使用。
      <p>在 Pylint 1.0.0 中添加。</p>
      <p>不建议使用此规则，可使用 {rule:python:S1131} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0304</key>
    <name><![CDATA[最终换行符丢失]]></name>
    <configKey>C0304</configKey>
    <description>
      <![CDATA[当文件的最后一行缺少换行符时使用。
               <p>尽管Python解释器通常不要求最后一行的行尾字符，但是其他处理Python
			   源文件的程序可能需要，并且加换行符是一个很好的习惯。</p>
               <p>在 Pylint 1.0.0 中添加。</p>
               <p>不建议使用此规则，可使用 {rule:python:S113} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0305</key>
    <name><![CDATA[尾随换行符]]></name>
    <configKey>C0305</configKey>
    <description>
      <![CDATA[当文件中有尾随空白行时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0321</key>
    <name><![CDATA[在同一行中有多个语句]]></name>
    <configKey>C0321</configKey>
    <description>
      <![CDATA[<p>当同一行上找到多个语句时使用。</p>
      <p>不建议使用此规则，可使用 {rule:python:OneStatementPerLine} 来代替。</p>]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0322</key>
    <name><![CDATA[运算符前没有空格]]></name>
    <configKey>C0322</configKey>
    <description>
      <![CDATA[当下列运算符之一（!= | <= | == | >= | < | > | = | \+= |-= | \*= | /= | %）前没有空格时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0323</key>
    <name><![CDATA[运算符后面没有空格]]></name>
    <configKey>C0323</configKey>
    <description>
      <![CDATA[当下列运算符之一（!= | <= | == | >= | < | > | = | \+= |-= | \*= | /= | %）后没有空格时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0324</key>
    <name><![CDATA[逗号后没有空格]]></name>
    <configKey>C0324</configKey>
    <description>
      <![CDATA[当逗号（","）后面没有空格时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0325</key>
    <name><![CDATA[不必要的括号]]></name>
    <configKey>C0325</configKey>
    <description>
      <![CDATA[当括号中的单个项目后接if，for或其他关键字时使用。
      <p>该规则在Pylint 1.1.0中添加。</p>
      <p>不建议使用此规则，可使用 {rule:python:S1110} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>C0326</key>
    <name><![CDATA[运算符、方括号、逗号周围，或块开始符之前的空格数量错误]]></name>
    <configKey>C0326</configKey>
    <description>
      <![CDATA[当运算符、括号或块开始符周围使用错误数量的空格时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0327</key>
    <name><![CDATA[混合行以LF和CRLF结尾]]></name>
    <configKey>C0327</configKey>
    <description>
      <![CDATA[当文件中包含换行符（LF和CRLF）时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0328</key>
    <name><![CDATA[意料之外的行结束格式]]></name>
    <configKey>C0328</configKey>
    <description>
      <![CDATA[当换行符与预期的不同时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0330</key>
    <name><![CDATA[错误的延续]]></name>
    <configKey>C0330</configKey>
    <description>
      <![CDATA[<p>当连续的行严重缩进时使用。</p>
      <p>该规则在Pylint 1.2.1中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0401</key>
    <name><![CDATA[注释中的单词拼写错误]]></name>
    <configKey>C0401</configKey>
    <description>
      <![CDATA[当注释中的单词拼写不正确时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0402</key>
    <name><![CDATA[文档字符串中的单词拼写错误]]></name>
    <configKey>C0402</configKey>
    <description>
      <![CDATA[当文档字符串中的单词拼写错误时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0403</key>
    <name><![CDATA[文档字符串中存在无效字符]]></name>
    <configKey>C0403</configKey>
    <description>
      <![CDATA[当enchant无法识别出文档字符串中的单词时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0410</key>
    <name><![CDATA[一行中有多次导入（多个import）]]></name>
    <configKey>C0410</configKey>
    <description>
      <![CDATA[当检测到导入语句导入多个模块时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0411</key>
    <name><![CDATA[导入顺序错误]]></name>
    <configKey>C0411</configKey>
    <description>
      <![CDATA[在不遵守PEP8导入顺序时使用（首先是标准导入，然后是第三方库，再是本地导入）]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0412</key>
    <name><![CDATA[未分组的导入]]></name>
    <configKey>C0412</configKey>
    <description>
      <![CDATA[当导入未按包分组时使用]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0413</key>
    <name><![CDATA[导入（import）位置错误]]></name>
    <configKey>C0413</configKey>
    <description>
      <![CDATA[在代码和导入（import）混合使用时使用]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C1001</key>
    <name><![CDATA[定义了老式类。]]></name>
    <configKey>C1001</configKey>
    <description>
      <![CDATA[当一个类既不从另一个类继承也不是显式继承“对象”的类时使用。使用Python> = 3.0时不会发出此消息。
      <p>该规则在Pylint 1.0.0时添加。</p>
      <p>不建议使用此规则，可使用{rule：python：S1722}来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C0414</key>
    <name><![CDATA[导入别名不会重命名原始包]]></name>
    <configKey>C0414</configKey>
    <description>
      <![CDATA[当导入别名与原始软件包名称相同时使用，例如要使用import numpy as numpy而不是import numpy as np]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>C1801</key>
    <name><![CDATA[不要使用len（SEQUENCE）来确定序列是否为空]]></name>
    <configKey>C1801</configKey>
    <description>
      <![CDATA[当Pylint检测到在条件内部使用len（sequence）来确定序列是否为空时使用。 不用将长度与0进行比较，而是要依靠空序列为假来判断。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0001</key>
    <name><![CDATA[语法错误]]></name>
    <configKey>E0001</configKey>
    <description>
      <![CDATA[当模块中出现语法错误时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0011</key>
    <name><![CDATA[无法识别的文件选项]]></name>
    <configKey>E0011</configKey>
    <description>
      <![CDATA[在遇到未知的内联选项时使用。
               <p>请注意，可以在配置文件中指定选项，并且可以在命令行中覆盖这些选项。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0012</key>
    <name><![CDATA[错误的选项值]]></name>
    <configKey>E0012</configKey>
    <description>
      <![CDATA[当遇到错误的内联选项的值时使用。
               <p>该选项存在，但其值无效。 这些选项可以在
			   Pylint配置文件中指定，并且可以在Pylint命令
			   行中覆盖。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0100</key>
    <name><![CDATA[ __init__ 方法是一个生成器]]></name>
    <configKey>E0100</configKey>
    <description>
      <![CDATA[当特殊类方法 __init__ 通过其主体中的yield关键字转换为生成器时使用。
               <p>__init __()方法是不需要返回任何内容的。 当调用__init __()并执行yield语句
			   时，Python 2.7和3.x会弹出TypeError（类型错误）。 Pylint报告此错误时，
			   并不依赖于实际调用。</p>
               <p>不建议使用此规则，可使用 {rule：python：S2734} 来代替。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0101</key>
    <name><![CDATA[____init__中的显式返回]]></name>
    <configKey>E0101</configKey>
    <description>
      <![CDATA[当特殊类方法 __init__ 具有显式的返回值时使用。
               <p>__init __()方法是不需要返回任何内容的。 当调用__init __()并执行
			   一个非None值的return语句时，Python会弹出TypeError（类型错误）。 
			   Pylint报告此错误时，并不依赖于实际调用。</p>
               <p>不建议使用此规则，可使用 {rule：python：S2734} 来代替。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0102</key>
    <name><![CDATA[重新定义函数/类/方法]]></name>
    <configKey>E0102</configKey>
    <description>
      <![CDATA[当一个函数/类/方法被重新定义时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0103</key>
    <name><![CDATA[循环外使用 “break” 或 “continue”]]></name>
    <configKey>E0103</configKey>
    <description>
      <![CDATA[在循环外使用break或continue关键字时使用。
      <p>不建议使用此规则，可使用 {rule:python:S1716} 来代替。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0104</key>
    <name><![CDATA[在函数之外使用 “return”]]></name>
    <configKey>E0104</configKey>
    <description>
      <![CDATA[在函数或方法之外找到 “return” 语句时使用。
      <p>不建议使用此规则，可使用 {rule:python:S2711} 来代替。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0105</key>
    <name><![CDATA[在函数之外使用 “yield”]]></name>
    <configKey>E0105</configKey>
    <description>
      <![CDATA[在函数或方法之外找到 “yield” 语句时使用。
      <p>不建议使用此规则，可使用 {rule:python:S2711} 来代替。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0106</key>
    <name><![CDATA[在生成器内部返回参数]]></name>
    <configKey>E0106</configKey>
    <description>
      <![CDATA[在生成器函数或方法的外部找到带有参数的 “return” 语句时使用（例如带有一些“ yield”语句）。 使用Python> = 3.3时不会发出此消息。
      <p>不建议使用此规则，可使用 {rule:python:S2712} 来代替。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0107</key>
    <name><![CDATA[使用了不存在的运算符]]></name>
    <configKey>E0107</configKey>
    <description>
      <![CDATA[当你尝试使用C样式的自增或自减运算符++和--（在Python中不存在）时使用。
               <p>不建议使用此规则，可使用 {rule:PreIncrementDecrement} 来代替。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0108</key>
    <name><![CDATA[函数定义中的参数名称重复]]></name>
    <configKey>E0108</configKey>
    <description>
      <![CDATA[函数定义中重复的参数名称是语法错误。
        <p>该规则在Pylint 0.28.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0109</key>
    <name><![CDATA[缺少给reversed()的参数]]></name>
    <configKey>E0109</configKey>
    <description>
      <![CDATA[当内建的reversed()没有接收到参数时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0110</key>
    <name><![CDATA[抽象类被实例化]]></name>
    <configKey>E0110</configKey>
    <description>
      <![CDATA[当把“ abc.ABCMeta ”作为metaclass类的抽象类具有抽象方法并被实例化时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0111</key>
    <name><![CDATA[reversed()的第一个参数不是序列]]></name>
    <configKey>E0111</configKey>
    <description>
      <![CDATA[当reversed() builtin的第一个参数不是序列时使用
       （既没有使用 __reversed__ ，也没有使用 __getitem__    
      <p>该规则在Pylint 1.2.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0112</key>
    <name><![CDATA[作业中有多个已加注星标的表达]]></name>
    <configKey>E0112</configKey>
    <description>
      <![CDATA[当一个作业中有多个加星标的表达式（“ * x ”）时发出。 这是一个语法错误。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0113</key>
    <name><![CDATA[已加星标的赋值目标必须在列表或元组中]]></name>
    <configKey>E0113</configKey>
    <description>
      <![CDATA[当星号表达式用作带星号的赋值目标时发出。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0114</key>
    <name><![CDATA[只能在赋值目标中使用加星标的表达式]]></name>
    <configKey>E0114</configKey>
    <description>
      <![CDATA[使用星型表达式，却并没有在赋值目标中使用时发出。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0115</key>
    <name><![CDATA[变量不仅被定义为非局部（nonlocal）同时被定义为全局（global）]]></name>
    <configKey>E0115</configKey>
    <description>
      <![CDATA[当变量同时被定义为非局部（nonlocal）和全局（global）时发出。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0116</key>
    <name><![CDATA[“finally” 子句中不支持 “continue”]]></name>
    <configKey>E0116</configKey>
    <description>
      <![CDATA[在finally子句中找到 “continue” 关键字时发出，它是一个语法错误。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0117</key>
    <name><![CDATA[找到了未绑定的非局部（nonlocal）变量]]></name>
    <configKey>E0117</configKey>
    <description>
      <![CDATA[当非局部（nonlocal）变量在父作用域中没有附加名称时发出]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0119</key>
    <name><![CDATA[未在str上调用format函数]]></name>
    <configKey>E0119</configKey>
    <description>
      <![CDATA[在str对象上未调用format函数时发出。 例如，执行print("value: {}").format(123)而不是print("value: {}".format(123))。 这可能不是用户想要的。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0202</key>
    <name><![CDATA[被超类属性隐藏的方法]]></name>
    <configKey>E0202</configKey>
    <description>
      <![CDATA[当类定义一个方法时，该方法被祖先类的实例属性隐藏或由某些客户端代码设置时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0203</key>
    <name><![CDATA[在定义之前访问成员（member）]]></name>
    <configKey>E0203</configKey>
    <description>
      <![CDATA[在实例成员（member）被实际分配之前对其进行访问时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0211</key>
    <name><![CDATA[方法没有参数]]></name>
    <configKey>E0211</configKey>
    <description>
      <![CDATA[当应该将绑定实例作为第一个参数的方法未定义参数时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0213</key>
    <name><![CDATA[方法应以 “self” 作为第一个参数]]></name>
    <configKey>E0213</configKey>
    <description>
      <![CDATA[当方法的属性与 “self” 作为第一个参数具有不同的属性时使用。 这被认为是一个错误，因为这是非常常见的约定，您不应该破坏它！]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0221</key>
    <name><![CDATA[实现的接口必须是一个类]]></name>
    <configKey>E0221</configKey>
    <description>
      <![CDATA[当类声明实现不是类的接口时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0222</key>
    <name><![CDATA[接口缺少方法]]></name>
    <configKey>E0222</configKey>
    <description>
      <![CDATA[在实现此接口的类中缺少接口中声明的方法时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0235</key>
    <name><![CDATA[__exit__必须接收3个参数：类型（type），值（value），回溯（traceback）]]></name>
    <configKey>E0235</configKey>
    <description>
      <![CDATA[当属于上下文管理器（context manager）的__exit__特殊方法未接收到3个参数（type，value，traceback）时使用。
        <p>该规则在Pylint 1.1.0中添加。</p>
        <p>不建议使用此规则，可使用 {rule:python:S2733} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>E0236</key>
    <name><![CDATA[__slots__ 中的无效对象，只能包含非空字符串]]></name>
    <configKey>E0236</configKey>
    <description>
      <![CDATA[当 __slots__ 中出现无效（非字符串）对象时使用。
         <p>该规则在Pylint 1.2.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0237</key>
    <name><![CDATA[给未在类的 __slots__ 中定义的属性分配了内存]]></name>
    <configKey>E0237</configKey>
    <description>
      <![CDATA[当分配给未在类的 __slots__ 中定义的属性内存时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0238</key>
    <name><![CDATA[无效的 __slots__ 对象]]></name>
    <configKey>E0238</configKey>
    <description>
      <![CDATA[当在类中发现无效的 __slots__ 时使用。 仅允许使用字符串、迭代或者序列。
        <p>该规则在Pylint 1.2.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0239</key>
    <name><![CDATA[从不是类的模块处继承]]></name>
    <configKey>E0239</configKey>
    <description>
      <![CDATA[当一个类继承自不是类的模块时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0240</key>
    <name><![CDATA[方法解析顺序不一致]]></name>
    <configKey>E0240</configKey>
    <description>
      <![CDATA[当类的方法解析顺序不一致时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0241</key>
    <name><![CDATA[基数（bases）重复]]></name>
    <configKey>E0241</configKey>
    <description>
      <![CDATA[当一个类具有重复的基数（bases）时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0301</key>
    <name><![CDATA[__iter__ 返回不可迭代内容]]></name>
    <configKey>E0301</configKey>
    <description>
      <![CDATA[当 __iter__ 方法返回不可迭代的内容时使用（即没有“ __next__”方法）]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0302</key>
    <name><![CDATA[意料之外的特殊方法签名（method signature）]]></name>
    <configKey>E0302</configKey>
    <description>
      <![CDATA[当使用无效数目的参数定义特殊方法时发出。 如果数目太少或太多，则可能根本无法工作。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0303</key>
    <name><![CDATA[__len__ 未返回非负整数]]></name>
    <configKey>E0303</configKey>
    <description>
      <![CDATA[当 __len__ 方法返回的不是非负整数的值时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0401</key>
    <name><![CDATA[导入（import）错误]]></name>
    <configKey>E0401</configKey>
    <description>
      <![CDATA[当pylint无法导入模块时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0402</key>
    <name><![CDATA[尝试了超出顶级包的相对导入]]></name>
    <configKey>E0402</configKey>
    <description>
      <![CDATA[当相对导入尝试访问当前包中的太多级别时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0501</key>
    <name><![CDATA[检测到了非ASCII字符，但未指定编码（PEP 263）]]></name>
    <configKey>E0501</configKey>
    <description>
      <![CDATA[如PEP 263所述，当检测到某些非ASCII字符但未指定编码时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0502</key>
    <name><![CDATA[指定的编码错误]]></name>
    <configKey>E0502</configKey>
    <description>
      <![CDATA[当指定了已知的编码，但文件似乎实际上不是这种编码时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0503</key>
    <name><![CDATA[指定了未知的编码]]></name>
    <configKey>E0503</configKey>
    <description>
      <![CDATA[在指定了编码，但该编码在Python中是未知时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0601</key>
    <name><![CDATA[在分配之前访问变量]]></name>
    <configKey>E0601</configKey>
    <description>
      <![CDATA[在分配前访问局部变量时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0602</key>
    <name><![CDATA[未定义的变量]]></name>
    <configKey>E0602</configKey>
    <description>
      <![CDATA[在访问未定义的变量时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0603</key>
    <name><![CDATA[__all__ 中有未定义的变量名]]></name>
    <configKey>E0603</configKey>
    <description>
      <![CDATA[在 __all__ 中引用未定义的变量名称时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0604</key>
    <name><![CDATA[__all__ 中含有无效对象，只能包含字符串]]></name>
    <configKey>E0604</configKey>
    <description>
      <![CDATA[在 __all__ 中出现无效（非字符串）对象时使用。
       <p>该规则在Pylint 0.27.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0611</key>
    <name><![CDATA[模块中存在未定义的名称]]></name>
    <configKey>E0611</configKey>
    <description>
      <![CDATA[在模块中找不到名称时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0632</key>
    <name><![CDATA[不平衡的元组拆包（tuple unpacking）]]></name>
    <configKey>E0632</configKey>
    <description>
      <![CDATA[在分配中存在不平衡的元组拆包（tuple unpacking）时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0633</key>
    <name><![CDATA[尝试将一个非序列拆包]]></name>
    <configKey>E0633</configKey>
    <description>
      <![CDATA[在将一个非序列拆包分配时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0701</key>
    <name><![CDATA[except子句排列顺序错误]]></name>
    <configKey>E0701</configKey>
    <description>
      <![CDATA[当 except 子句的顺序（从更具体到更通用）不正确时使用。 如果您不修复顺序，则最具体的处理器可能不会捕获到某些异常。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0702</key>
    <name><![CDATA[引发了仅允许是类、实例和字符串的内容]]></name>
    <configKey>E0702</configKey>
    <description>
      <![CDATA[当引发了既不是类、实例又不是字符串的内容时使用（即将引发“ TypeError”）。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0703</key>
    <name><![CDATA[Exception上下文的设置既不是一个异常也不是None]]></name>
    <configKey>E0703</configKey>
    <description>
      <![CDATA[在使用语法“ raise ... from ...”时，异常上下文既不是异常也不是None时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E0704</key>
    <name><![CDATA[引发的语句不在 except 子句中]]></name>
    <configKey>E0704</configKey>
    <description>
      <![CDATA[当 except 子句中未使用空白的 raise 时使用。 这会产生一个错误，因为没有活跃的异常（exception）要重新引发。 只要在 try 块内引发异常（exception），此规则的异常就可以通过 finally 子句中一个空白的 raise 来表示，这可能是可行的，但这仍然是不能依赖的代码味道（code smell）。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0710</key>
    <name><![CDATA[引发一个未继承自 BaseException 的新式类]]></name>
    <configKey>E0710</configKey>
    <description>
      <![CDATA[当引发出一个未继承自 BaseException 的新式类时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0711</key>
    <name><![CDATA[引发了 NotImplemented ——应该引发 NotImplementedError]]></name>
    <configKey>E0711</configKey>
    <description>
      <![CDATA[在引发出了 NotImplemented 而不是 NotImplementedError 时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E0712</key>
    <name><![CDATA[捕获到没有继承自 Exception 的异常]]></name>
    <configKey>E0712</configKey>
    <description>
      <![CDATA[当未继承自 Exception 的类在 except 子句中用作异常时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E1001</key>
    <name><![CDATA[在老式类上使用 __slots__]]></name>
    <configKey>E1001</configKey>
    <description>
      <![CDATA[当老式类使用 __slots__ 属性时使用。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1002</key>
    <name><![CDATA[在旧式类中使用super]]></name>
    <configKey>E1002</configKey>
    <description>
      <![CDATA[当旧式类使用super builtin函数时使用。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1003</key>
    <name><![CDATA[错误的给出super的第一个参数]]></name>
    <configKey>E1003</configKey>
    <description>
      <![CDATA[当将当前类以外的另一个参数作为super builtin函数的第一个参数给出时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1004</key>
    <name><![CDATA[super()缺少参数]]></name>
    <configKey>E1004</configKey>
    <description>
      <![CDATA[当 super() builtin函数未收到参数时使用。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E1101</key>
    <name><![CDATA[访问不存在的成员]]></name>
    <configKey>E1101</configKey>
    <description>
      <![CDATA[当不存在的成员访问变量时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1102</key>
    <name><![CDATA[调用了不可调用的对象]]></name>
    <configKey>E1102</configKey>
    <description>
      <![CDATA[当被调用的对象被推断为不可调用的对象时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1103</key>
    <name><![CDATA[正在访问不存在的成员（类型信息不完整）]]></name>
    <configKey>E1103</configKey>
    <description>
      <![CDATA[当不存在的成员访问变量时使用，但是 Pylint 无法解释该变量的所有可能类型。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1111</key>
    <name><![CDATA[对没有返回值的函数调用时进行赋值]]></name>
    <configKey>E1111</configKey>
    <description>
      <![CDATA[在函数调用中完成赋值但是推断的函数不返回任何内容时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1120</key>
    <name><![CDATA[参数太少]]></name>
    <configKey>E1120</configKey>
    <description>
      <![CDATA[当函数调用传递的参数太少时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1121</key>
    <name><![CDATA[函数调用的位置参数（positional argument）过多]]></name>
    <configKey>E1121</configKey>
    <description>
      <![CDATA[当函数调用传递太多位置参数（positional argument）时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1122</key>
    <name><![CDATA[函数调用中的关键字参数（keyword argument）重复]]></name>
    <configKey>E1122</configKey>
    <description>
      <![CDATA[当函数调用多次传递相同的关键字参数（keyword argument）时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1123</key>
    <name><![CDATA[在函数调用中传递意料之外的关键字参数（keyword argument）]]></name>
    <configKey>E1123</configKey>
    <description>
      <![CDATA[当函数调用传递与该函数的参数名称不对应的关键字参数时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1124</key>
    <name><![CDATA[在函数调用中给参数传递了多个值]]></name>
    <configKey>E1124</configKey>
    <description>
      <![CDATA[当函数调用时向函数参数分配多个值时使用，其中一个值来自位置参数（positional argument），一个值来自关键字参数（keyword argument）。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1125</key>
    <name><![CDATA[调用时缺少必要关键字参数]]></name>
    <configKey>E1125</configKey>
    <description>
      <![CDATA[当函数调用未传递必要的关键字（仅参数）时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1126</key>
    <name><![CDATA[序列索引不是整型、切片（slice），或者是具有 __index__ 的实例（instance）]]></name>
    <configKey>E1126</configKey>
    <description>
      <![CDATA[当序列类型被无效类型索引时使用。 有效类型是整型、切片（slice）、使用 __index__ 方法的对象。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1127</key>
    <name><![CDATA[切片（slice）索引不是整型，None或具有__index__的实例（instance）]]></name>
    <configKey>E1127</configKey>
    <description>
      <![CDATA[当切片索引不是整数，None或带有 __index__ 方法的对象时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1128</key>
    <name><![CDATA[对返回None的函数调用时进行赋值]]></name>
    <configKey>E1128</configKey>
    <description>
      <![CDATA[在函数调用上完成赋值但推断的函数仅返回None时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1129</key>
    <name><![CDATA[上下文管理器未实现 __enter__ 和 __exit__]]></name>
    <configKey>E1129</configKey>
    <description>
      <![CDATA[当 with 语句中的实例未实现上下文管理器协议（__enter __ / __ exit__）时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1130</key>
    <name><![CDATA[一元操作数（unary oprand）类型无效]]></name>
    <configKey>E1130</configKey>
    <description>
      <![CDATA[在不支持此类操作的对象上使用一元操作数（unary oprand）时发出。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1131</key>
    <name><![CDATA[不支持二进制操作]]></name>
    <configKey>E1131</configKey>
    <description>
      <![CDATA[当不支持两个操作数之间的二进制算术运算时发出。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1132</key>
    <name><![CDATA[关键字参数获得多个值]]></name>
    <configKey>E1132</configKey>
    <description>
      <![CDATA[当一个函数调用获得一个关键字的多个值时发出。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1133</key>
    <name><![CDATA[迭代上下文中使用了不可迭代值]]></name>
    <configKey>E1133</configKey>
    <description>
      <![CDATA[当在应当使用可迭代值的地方使用不可迭代的值时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1134</key>
    <name><![CDATA[映射上下文中使用了非映射值]]></name>
    <configKey>E1134</configKey>
    <description>
      <![CDATA[当在应当使用映射的地方使用非映射值时使用]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1135</key>
    <name><![CDATA[未通过成员资格测试]]></name>
    <configKey>E1135</configKey>
    <description>
      <![CDATA[当成员资格测试表达式中的实例未实现成员资格协议（__contains __ / __ iter __ / __ getitem__）时发出。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1136</key>
    <name><![CDATA[无法按照下标的值访问]]></name>
    <configKey>E1136</configKey>
    <description>
      <![CDATA[当下标的值不支持访问时发出（即未定义 __getitem__ 方法）。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1137</key>
    <name><![CDATA[对象不支持项目分配]]></name>
    <configKey>E1137</configKey>
    <description>
      <![CDATA[当对象不支持项目分配时发出（即未定义 __setitem__ 方法）。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1138</key>
    <name><![CDATA[对象不支持项目删除]]></name>
    <configKey>E1138</configKey>
    <description>
      <![CDATA[当对象不支持项目删除时发出（即未定义 __delitem_方法）。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1139</key>
    <name><![CDATA[使用了无效的metaclass方法]]></name>
    <configKey>E1139</configKey>
    <description>
      <![CDATA[当检测到一个类正在使用某类作为metaclass类，但是将其用作metaclass类可能是无效的时候，就发出该信息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1140</key>
    <name><![CDATA[字典的键不是可哈希的（hashable）]]></name>
    <configKey>E1140</configKey>
    <description>
      <![CDATA[当字典键不时可哈希的时发出（即未定义 __hash__ 方法）。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1200</key>
    <name><![CDATA[不支持的日志格式字符]]></name>
    <configKey>E1200</configKey>
    <description>
      <![CDATA[在日志记录语句格式字符串中使用了不受支持的格式字符时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1201</key>
    <name><![CDATA[记录格式字符串在转换说明符的中间结束]]></name>
    <configKey>E1201</configKey>
    <description>
      <![CDATA[当日志记录语句格式字符串在转换说明符的结尾之前终止时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1205</key>
    <name><![CDATA[记录格式字符串的参数过多]]></name>
    <configKey>E1205</configKey>
    <description>
      <![CDATA[给日志记录格式字符串提供太多参数时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1206</key>
    <name><![CDATA[参数过少，无法记录格式字符串]]></name>
    <configKey>E1206</configKey>
    <description>
      <![CDATA[当日志记录格式字符串的参数太少时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1300</key>
    <name><![CDATA[不支持的格式字符]]></name>
    <configKey>E1300</configKey>
    <description>
      <![CDATA[在格式字符串中使用不受支持的格式字符时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1301</key>
    <name><![CDATA[格式字符串在转换说明符的中间结束]]></name>
    <configKey>E1301</configKey>
    <description>
      <![CDATA[当格式字符串在转换说明符的结尾之前终止时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1302</key>
    <name><![CDATA[在格式字符串中混合已命名的和未命名的转换说明符]]></name>
    <configKey>E1302</configKey>
    <description>
      <![CDATA[当格式字符串同时包含命名的（例如 '%(foo)d'）和未命名的（例如'%d'）转换说明符时使用。 当指定的转换说明符包含 * 表示最小字段宽度和/或精度时，也可以使用此选项。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1303</key>
    <name><![CDATA[格式字符串期望映射参数]]></name>
    <configKey>E1303</configKey>
    <description>
      <![CDATA[当使用命名转换说明符的格式字符串与非映射参数一起使用时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1304</key>
    <name><![CDATA[格式字符串字典中缺少键]]></name>
    <configKey>E1304</configKey>
    <description>
      <![CDATA[当使用命名转换说明符的格式字符串与不包含格式字符串所需的所有键的字典一起使用时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1305</key>
    <name><![CDATA[格式字符串的参数过多]]></name>
    <configKey>E1305</configKey>
    <description>
      <![CDATA[当给使用未命名的转换说明符的格式字符串提供太多参数时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1306</key>
    <name><![CDATA[格式字符串的参数过少]]></name>
    <configKey>E1306</configKey>
    <description>
      <![CDATA[当使用未命名的转换说明符的格式字符串的参数设置过少时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1307</key>
    <name><![CDATA[参数与格式类型不匹配]]></name>
    <configKey>E1307</configKey>
    <description>
      <![CDATA[当格式字符串所需的类型不适合实际参数类型时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E1310</key>
    <name><![CDATA[lstrip / rstrip中含有可疑参数]]></name>
    <configKey>E1310</configKey>
    <description>
      <![CDATA[str.{l,r}strip调用的参数包含重复字符。
      <p>该规则在Pylint 0.28.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E1507</key>
    <name><![CDATA[Env操作函数（manipulation functions）不支持类型参数]]></name>
    <configKey>E1507</configKey>
    <description>
      <![CDATA[Env操作函数（manipulation functions）仅支持字符串类型参数。 参见https://docs.python.org/3/library/os.html#os.getenv。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>E1601</key>
    <name><![CDATA[使用了print语句]]></name>
    <configKey>E1601</configKey>
    <description>
      <![CDATA[在使用print语句时使用（`print`是Python 3中的函数）]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1602</key>
    <name><![CDATA[指定参数拆包（Parameter unpacking）]]></name>
    <configKey>E1602</configKey>
    <description>
      <![CDATA[为函数指定参数拆包（parameter unpacking）时使用（Python 3不允许使用）]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1603</key>
    <name><![CDATA[Python 3不支持隐式拆包异常]]></name>
    <configKey>E1603</configKey>
    <description>
      <![CDATA[Python3不允许在except子句中隐式解包异常。 参见http://www.python.org/dev/peps/pep-3110/。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1604</key>
    <name><![CDATA[使用raise ErrorClass(args)而不是raise ErrorClass, args。]]></name>
    <configKey>E1604</configKey>
    <description>
      <![CDATA[当使用替代的raise语法“ raise foo, bar”来代替“ raise foo(bar)”时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1605</key>
    <name><![CDATA[使用了 `` 运算符]]></name>
    <configKey>E1605</configKey>
    <description>
      <![CDATA[当使用了不推荐使用的“ ` ` “（反引号）运算符而没有使用str()函数时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1606</key>
    <name><![CDATA[使用长后缀]]></name>
    <configKey>E1606</configKey>
    <description>
      <![CDATA[当使用 “l” 或 “ L” 标记长整数时使用。 这在Python 3中不起作用，因为`int`和`long`类型已合并。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1607</key>
    <name><![CDATA[使用 <> 运算符]]></name>
    <configKey>E1607</configKey>
    <description>
      <![CDATA[当使用了不推荐使用的 “<>” 运算符而没有使用 “ != ” 时使用。 在Python 3中已将其删除。使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1608</key>
    <name><![CDATA[使用旧的八进制字符]]></name>
    <configKey>E1608</configKey>
    <description>
      <![CDATA[遇到旧的八进制语法时使用，已在Python 3中删除。要使用新的语法，请在数字前加0o。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1609</key>
    <name><![CDATA[仅在模块级别允许import *]]></name>
    <configKey>E1609</configKey>
    <description>
      <![CDATA[在模块级别以外的其他地方使用import *语法时使用。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1610</key>
    <name><![CDATA[3.x不支持非ascii字节字符]]></name>
    <configKey>E1610</configKey>
    <description>
      <![CDATA[在程序中找到非ascii字节字符时使用。 Python 3不再支持它们。使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1700</key>
    <name><![CDATA[在异步函数内部使用yield]]></name>
    <configKey>E1700</configKey>
    <description>
      <![CDATA[在异步函数中找到`yield`或`yield from`语句时使用。 使用Python <3.5时不会发出此消息。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>E1701</key>
    <name><![CDATA[异步上下文管理器未实现__aenter__和__aexit__]]></name>
    <configKey>E1701</configKey>
    <description>
      <![CDATA[当异步上下文管理器与未实现异步上下文管理协议的对象一起使用时使用。 使用Python <3.5时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>F0001</key>
    <name><![CDATA[分析失败]]></name>
    <configKey>F0001</configKey>
    <description>
      <![CDATA[在发生错误而无法分析模块（例如无法找到它）时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0002</key>
    <name><![CDATA[内部Pylint错误]]></name>
    <configKey>F0002</configKey>
    <description>
      <![CDATA[在构建Astroid表示形式时发生意外错误时使用。 通常伴随着回溯。 请报告此类错误！]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0003</key>
    <name><![CDATA[忽略内置模块]]></name>
    <configKey>F0003</configKey>
    <description>
      <![CDATA[用于指示用户要求分析已跳过的内置模块。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0004</key>
    <name><![CDATA[意料之外的推断值]]></name>
    <configKey>F0004</configKey>
    <description>
      <![CDATA[用于指示已推断出某些意外类型的值。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0010</key>
    <name><![CDATA[代码解析时出错]]></name>
    <configKey>F0010</configKey>
    <description>
      <![CDATA[在构建Astroid表示形式时发生异常，可以由astroid处理时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0202</key>
    <name><![CDATA[无法检查方法签名]]></name>
    <configKey>F0202</configKey>
    <description>
      <![CDATA[当Pylint由于意外原因无法检查方法签名兼容性时使用。 如果您不了解，请报告这种情况。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0220</key>
    <name><![CDATA[解析接口失败]]></name>
    <configKey>F0220</configKey>
    <description>
      <![CDATA[当Pylint未能找到由类实现的接口时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0321</key>
    <name><![CDATA[格式检测错误]]></name>
    <configKey>F0321</configKey>
    <description>
      <![CDATA[在错误的格式检测中发生意外错误时使用。 如果发生错误，请报告错误。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>F0401</key>
    <name><![CDATA[无法导入（import）模块]]></name>
    <configKey>F0401</configKey>
    <description>
      <![CDATA[当Pylint无法导入（import）模块时使用。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>I0001</key>
    <name><![CDATA[无法在内置模块上运行原始检查器]]></name>
    <configKey>I0001</configKey>
    <description>
      <![CDATA[用于通知未使用原始检查器检查的内置模块。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0010</key>
    <name><![CDATA[无法识别内联选项]]></name>
    <configKey>I0010</configKey>
    <description>
      <![CDATA[当内联选项格式错误或无法在模块内部使用时使用。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0011</key>
    <name><![CDATA[本地禁用消息]]></name>
    <configKey>I0011</configKey>
    <description>
      <![CDATA[在内联选项禁用消息或消息类别时使用。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0012</key>
    <name><![CDATA[本地启用消息]]></name>
    <configKey>I0012</configKey>
    <description>
      <![CDATA[内联选项启用消息或消息类别时使用。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0013</key>
    <name><![CDATA[忽略整个文件]]></name>
    <configKey>I0013</configKey>
    <description>
      <![CDATA[用于通知将不检查该文件。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0020</key>
    <name><![CDATA[禁止的消息]]></name>
    <configKey>I0020</configKey>
    <description>
      <![CDATA[一条消息在一行上触发，但被文件中的 disable=注释显式禁止。 对于由于配置设置而被忽略的消息，不会生成此消息。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0021</key>
    <name><![CDATA[禁止了无用的消息]]></name>
    <configKey>I0021</configKey>
    <description>
      <![CDATA[当为一行或一段代码明确禁用一条消息，但从未触发该条消息时报告。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0022</key>
    <name><![CDATA[过时的pragma]]></name>
    <configKey>I0022</configKey>
    <description>
      <![CDATA[某些内联pylint选项已被重命名或重新设计，仅应使用最新形式。 注意：全部跳过仅适用于pylint> = 0.26。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I0023</key>
    <name><![CDATA[使用symbolic信息]]></name>
    <configKey>I0023</configKey>
    <description>
      <![CDATA[通过ID启用或禁用消息时使用。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>I1101</key>
    <name><![CDATA[C扩展不存在的成员]]></name>
    <configKey>I1101</configKey>
    <description>
      <![CDATA[当访问了不存在的C扩展成员变量时使用。 由于无法使用源，因此无法进行静态分析，但是可以通过在运行时自检活动对象来执行。]]>
    </description>
    <priority>INFO</priority>
  </rule>
  <rule>
    <key>R0123</key>
    <name><![CDATA[与字符进行比较]]></name>
    <configKey>R0123</configKey>
    <description>
      <![CDATA[在将对象与字符进行比较时使用，通常这是您不希望执行的操作，因为您可以将字符与完全不同的字符进行比较。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0124</key>
    <name><![CDATA[冗余比较]]></name>
    <configKey>R0124</configKey>
    <description>
      <![CDATA[当某物与自身进行比较时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0201</key>
    <name><![CDATA[方法可能是一个功能]]></name>
    <configKey>R0201</configKey>
    <description>
      <![CDATA[当方法不使用其绑定实例时使用，因此可以作为函数编写。
         <p>不建议使用此规则，可使用 {rule:python:S2325} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>R0202</key>
    <name><![CDATA[考虑使用装饰器（decorator）而不是调用classmethod]]></name>
    <configKey>R0202</configKey>
    <description>
      <![CDATA[在定义一个类方法而不使用装饰器（decorator）语法时使用。Used when a class method is defined without using the decorator syntax.]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0203</key>
    <name><![CDATA[考虑使用装饰器（decorator）而不是调用staticmethod]]></name>
    <configKey>R0203</configKey>
    <description>
      <![CDATA[在定义一个静态方法而不使用装饰器（decorator）语法时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0205</key>
    <name><![CDATA[类从对象（object）继承，可以从python3中的基类（bases）安全删除]]></name>
    <configKey>R0205</configKey>
    <description>
      <![CDATA[当类从python3为隐式的对象（object）继承时使用，因此该类可以安全地从基类中删除。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0401</key>
    <name><![CDATA[循环导入（import）]]></name>
    <configKey>R0401</configKey>
    <description>
      <![CDATA[当检测到两个或多个模块之间存在循环导入（import）时使用。
               <p>尽管循环导入（import）在大多数情况下会终止并且执行不会发生意外，
			   但循环依赖关系通常表明代码库中存在设计问题。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0801</key>
    <name><![CDATA[相似的行]]></name>
    <configKey>R0801</configKey>
    <description>
      <![CDATA[表示已在多个文件中检测到一组相似的行。 这通常意味着应重构代码以避免这种重复。
      <p>不建议使用此规则，可使用 {rule:common-py:DuplicatedBlocks} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>R0901</key>
    <name><![CDATA[父级太多]]></name>
    <configKey>R0901</configKey>
    <description>
      <![CDATA[当类的父类太多时使用，请尝试减少该类的使用以获得更简单（因此更易于使用）的类。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0902</key>
    <name><![CDATA[实例属性太多]]></name>
    <configKey>R0902</configKey>
    <description>
      <![CDATA[在类具有太多实例属性的情况下使用，请尝试减少此属性的使用以获得更简单（因此更易于使用）的类。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0903</key>
    <name><![CDATA[公开方法太少]]></name>
    <configKey>R0903</configKey>
    <description>
      <![CDATA[当类的公共方法太少时使用，因此请确保它的数量。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0904</key>
    <name><![CDATA[公开方法太多]]></name>
    <configKey>R0904</configKey>
    <description>
      <![CDATA[当类具有太多公共方法时使用，请尝试减少此方法以获得更简单（因此更易于使用）的类。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0911</key>
    <name><![CDATA[太多的 return 声明]]></name>
    <configKey>R0911</configKey>
    <description>
      <![CDATA[当函数或方法的return语句过多，以至于难以执行时使用。
      <p>不建议使用此规则，可使用 {rule:python:S1142} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>R0912</key>
    <name><![CDATA[分支太多]]></name>
    <configKey>R0912</configKey>
    <description>
      <![CDATA[当函数或方法的分支过多，以至于难以执行时使用。
               <p>不建议使用此规则，可使用 {rule:python:FunctionComplexity} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>R0913</key>
    <name><![CDATA[参数太多]]></name>
    <configKey>R0913</configKey>
    <description>
      <![CDATA[当函数或方法接受太多参数时使用。
      <p>不建议使用此规则，可使用 {rule:python:S107} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>R0914</key>
    <name><![CDATA[局部变量过多]]></name>
    <configKey>R0914</configKey>
    <description>
      <![CDATA[当函数或方法的局部变量过多时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0915</key>
    <name><![CDATA[语句过多]]></name>
    <configKey>R0915</configKey>
    <description>
      <![CDATA[当函数或方法的语句过多时使用。 应将其拆分为较小的函数/方法。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0916</key>
    <name><![CDATA[if 语句中的布尔表达式过多]]></name>
    <configKey>R0916</configKey>
    <description>
      <![CDATA[当 if 语句包含太多布尔表达式时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0921</key>
    <name><![CDATA[未引用抽象类]]></name>
    <configKey>R0921</configKey>
    <description>
      <![CDATA[当抽象类在任何地方都不用作父级或祖父级时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0922</key>
    <name><![CDATA[抽象类使用次数太少]]></name>
    <configKey>R0922</configKey>
    <description>
      <![CDATA[当抽象类用作父级或祖父级少于 X 次时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R0923</key>
    <name><![CDATA[接口未实现]]></name>
    <configKey>R0923</configKey>
    <description>
      <![CDATA[当接口类未在任何地方实现时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1701</key>
    <name><![CDATA[考虑合并isinstance调用]]></name>
    <configKey>R1701</configKey>
    <description>
      <![CDATA[在可将多个连续的isinstance调用合并为一个时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1702</key>
    <name><![CDATA[嵌套块太多]]></name>
    <configKey>R1702</configKey>
    <description>
      <![CDATA[当函数或方法具有太多嵌套块时使用。 这使得代码难以理解和难以维护。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1703</key>
    <name><![CDATA[可简化if语句]]></name>
    <configKey>R1703</configKey>
    <description>
      <![CDATA[当if语句可以用'bool（test）'替换时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1704</key>
    <name><![CDATA[用本地名称重新定义参数]]></name>
    <configKey>R1704</configKey>
    <description>
      <![CDATA[当一个本地名称重新定义参数，这可能表明存在潜在的错误时使用。 仅在少数名称绑定操作（例如，具有语句分配和异常处理程序分配的迭代）中考虑到这一点。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1705</key>
    <name><![CDATA[“return”后有不必要的“else”]]></name>
    <configKey>R1705</configKey>
    <description>
      <![CDATA[用于突出显示if语句（如果包含return语句）后不必要的代码块。 这样，它将在一系列ifs之后遇到else时发出警告，所有ifs都包含return语句。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1706</key>
    <name><![CDATA[考虑使用三元（ternary）]]></name>
    <configKey>R1706</configKey>
    <description>
      <![CDATA[当使用已知的Python 2.5之前的三元（ternary）语法之一时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1707</key>
    <name><![CDATA[不允许尾随逗号创建元组]]></name>
    <configKey>R1707</configKey>
    <description>
      <![CDATA[在Python中，元组（tuple）实际上是由逗号符号而不是括号创建的。 不幸的是，实际上可以通过放置尾随逗号来创建一个元组，这可能导致代码中潜在的奇怪错误。 您应该始终明确地使用括号来创建元组。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1708</key>
    <name><![CDATA[不要在生成器（generator）中raise StopIteration，而是使用return语句]]></name>
    <configKey>R1708</configKey>
    <description>
      <![CDATA[根据PEP479，使用StopIteration来结束生成器的循环可能会导致难以发现错误。 该PEP指定必须用简单的return语句替换raise StopIteration。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1709</key>
    <name><![CDATA[布尔表达式可以简化]]></name>
    <configKey>R1709</configKey>
    <description>
      <![CDATA[使用冗余的python 2.5之前的三元（ternary）语法时发出。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1710</key>
    <name><![CDATA[函数中的所有return语句应返回一个表达式，或者都不返回。]]></name>
    <configKey>R1710</configKey>
    <description>
      <![CDATA[根据PEP8，如果任何return语句返回一个表达式，则不返回任何值的任何return语句应将其显式声明为return None，并且在函数末尾（如果可访问）应存在一个显式return语句。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1711</key>
    <name><![CDATA[函数或方法结尾存在无用的返回]]></name>
    <configKey>R1711</configKey>
    <description>
      <![CDATA[在函数或方法定义的末尾找到单个“ return”或“ return None”语句时触发。 可以安全删除该语句，因为Python会隐式返回None。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1712</key>
    <name><![CDATA[考虑使用元组拆包（tuple unpacking）来交换变量]]></name>
    <configKey>R1712</configKey>
    <description>
      <![CDATA[您不必使用临时变量即可交换变量。 使用“tuple unpacking”直接交换变量可使意图更加清晰。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1713</key>
    <name><![CDATA[考虑使用str.join(sequence)连接可迭代对象中的字符串]]></name>
    <configKey>R1713</configKey>
    <description>
      <![CDATA[与for循环迭代相比，使用str.join(sequence)更快，并且会使用更少的内存并提高了可读性。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1714</key>
    <name><![CDATA[考虑使用“in”]]></name>
    <configKey>R1714</configKey>
    <description>
      <![CDATA[要检查某个变量是否等于多个值之一，请将这些值组合成一个元组（tuple），然后检查该变量是否包含在“in”中，而不是检查每个值是否相等。这样做更快且更省事。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1715</key>
    <name><![CDATA[考虑使用dict.get从dict获取值（如果存在键）或默认值（如果不存在）。]]></name>
    <configKey>R1715</configKey>
    <description>
      <![CDATA[使用内置的dict.get从字典中获取值（如果存在键）或使用默认值（如果不存在键）则更简单，并且被认为更习惯性使用，尽管有时会有一些慢。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1716</key>
    <name><![CDATA[简化操作数之间的链式比较]]></name>
    <configKey>R1716</configKey>
    <description>
      <![CDATA[当pylint遇到布尔运算（例如“ a < b and b < c ”）时，将发出此消息，建议将其改为“ a < b < c ”。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1717</key>
    <name><![CDATA[考虑使用字典解析（comprehension）]]></name>
    <configKey>R1717</configKey>
    <description>
      <![CDATA[尽管这段代码在语法上没有什么问题，但是它很难阅读并且可以简化为dict解析，而且速度更快，因为您无需创建另一个瞬态列表。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1718</key>
    <name><![CDATA[考虑使用集合解析（comprehension）]]></name>
    <configKey>R1718</configKey>
    <description>
      <![CDATA[尽管这段代码在语法上没有什么问题，但是它很难阅读并且可以简化为对集合的解析（set comprehension），而且速度更快，因为您无需创建另一个暂态列表。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1719</key>
    <name><![CDATA[if表达式可简化]]></name>
    <configKey>R1719</configKey>
    <description>
      <![CDATA[当if表达式可以用'bool(test)'替换时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>R1720</key>
    <name><![CDATA[在“raise”之后不必要的“else”]]></name>
    <configKey>R1720</configKey>
    <description>
      <![CDATA[用于突出显示if语句（如果包含raise语句）后的不必要的代码块。 这样，它将在ifs链之后遇到else时发出警告，所有ifs都包含一个raise语句。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0101</key>
    <name><![CDATA[无法访问的代码]]></name>
    <configKey>W0101</configKey>
    <description>
      <![CDATA[当在“return”或“raise”语句后面有某些代码（永远无法访问）时使用。
      <p>不建议使用此规则，可使用 {rule:python:S1763} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>W0102</key>
    <name><![CDATA[危险的默认值作为参数]]></name>
    <configKey>W0102</configKey>
    <description>
      <![CDATA[当在参数的默认值中检测到可变值作为列表（list）或字典（dictionary）时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0104</key>
    <name><![CDATA[声明似乎无效]]></name>
    <configKey>W0104</configKey>
    <description>
      <![CDATA[当一条语句没有（或至少看起来）没有任何效果时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0105</key>
    <name><![CDATA[字符串语句无效]]></name>
    <configKey>W0105</configKey>
    <description>
      <![CDATA[在将字符串用作语句时使用（这当然无效）。 这是W0104的特殊情况，带有其自身的消息，因此，如果您将这些字符串用作文档而不是注释，则可以轻松禁用它。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0106</key>
    <name><![CDATA[表达式未分配任何内容]]></name>
    <configKey>W0106</configKey>
    <description>
      <![CDATA[当不是函数调用的表达式未分配任何内容时使用。 可能还有其他意图。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0107</key>
    <name><![CDATA[不必要的pass声明]]></name>
    <configKey>W0107</configKey>
    <description>
      <![CDATA[在遇到可以避免的“pass”语句时使用。
      <p>不建议使用此规则，可使用 {rule:python:S2772} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>W0108</key>
    <name><![CDATA[Lambda可能不是必需的]]></name>
    <configKey>W0108</configKey>
    <description>
      <![CDATA[当lambda表达式的主体是与lambda本身在相同参数列表上的函数调用时使用； 除了少数情况外，此类lambda表达式可全部替换为lambda主体中所调用的函数。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0109</key>
    <name><![CDATA[字典中的重复键]]></name>
    <configKey>W0109</configKey>
    <description>
      <![CDATA[当字典表达式多次绑定相同的键时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0110</key>
    <name><![CDATA[lambda上的 map/filter 可以被解析（comprehension）替换]]></name>
    <configKey>W0110</configKey>
    <description>
      <![CDATA[当lambda是“ map”或“ filter”的第一个参数时使用。 作为列表解析（list comprehension）或生成器表达式（generator expression）可能会更清楚。 使用Python> = 3.0时不会发出此消息。
      <p>该规则在Pylint 0.27.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0111</key>
    <name><![CDATA[不应分配给新的Python关键字]]></name>
    <configKey>W0111</configKey>
    <description>
      <![CDATA[当由于引入了新的关键字而导致在将来的Python版本中分配将变得无效时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0120</key>
    <name><![CDATA[循环中的else子句，没有break语句]]></name>
    <configKey>W0120</configKey>
    <description>
      <![CDATA[如果循环可以使用break语句提前退出，则循环仅应具有else子句，否则else下的语句应与循环本身处于相同的作用域。
      <p>该规则在Pylint 0.28.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0121</key>
    <name><![CDATA[使用raise ErrorClass(args)而不是raise ErrorClass, args。]]></name>
    <configKey>W0121</configKey>
    <description>
      <![CDATA[当使用替代的raise语法“ raise foo, bar ”代替“ raise foo(bar) ”时使用。
        使用Python> = 3.0时不会发出此消息。
        <p>该规则在Pylint 1.0.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0122</key>
    <name><![CDATA[使用了exec]]></name>
    <configKey>W0122</configKey>
    <description>
      <![CDATA[当您使用“ exec ”语句（Python 3的函数）时弹出，以阻止其使用。 那并不意味着您不能使用它！
            <p>不建议使用此规则，可使用 {rule:python:ExecStatementUsage} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>W0123</key>
    <name><![CDATA[使用了eval]]></name>
    <configKey>W0123</configKey>
    <description>
      <![CDATA[当您使用“ eval ”功能时弹出，以阻止其使用。 考虑使用`ast.literal_eval`来安全评估包含来自不受信任来源的Python表达式的字符串。
        <p>该规则在Pylint 1.2.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0124</key>
    <name><![CDATA[“ as ”之后并连着另一个上下文管理器看起来像一个元组。]]></name>
    <configKey>W0124</configKey>
    <description>
      <![CDATA[当“ with ”语句组件返回多个值并且仅对其中一部分值使用与“ as ”的名称绑定时，如" with ctx() as a, b "，发出。 这可能会产生误导，因为尚不清楚上下文管理器是否返回元组，或者没有名称绑定的节点是否是另一个上下文管理器。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0125</key>
    <name><![CDATA[使用具有恒定值的条件语句]]></name>
    <configKey>W0125</configKey>
    <description>
      <![CDATA[当条件语句（If或ternary if）使用恒定值对其测试时发出。 这可能不是用户想要的。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0141</key>
    <name><![CDATA[使用黑名单中的内置功能]]></name>
    <configKey>W0141</configKey>
    <description>
      <![CDATA[当使用黑名单中的内置功能时使用（请参阅不良功能选项“ bad-function option ”）。 通常列入黑名单的函数是诸如 map 或 filter 之类的函数，Python现在提供了一些更简洁的替代方案，例如列表理解（list comprehension）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0142</key>
    <name><![CDATA[使用 * 或 ** magic]]></name>
    <configKey>W0142</configKey>
    <description>
      <![CDATA[当使用` *args `或` **kwargs `调用函数或方法来调度参数时使用。 这不会提高可读性，应谨慎使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0143</key>
    <name><![CDATA[与可调用对象（callable）进行比较，您是否省略了括号？]]></name>
    <configKey>W0143</configKey>
    <description>
      <![CDATA[当pylint检测到与可调用对象（callable）进行了比较时，将发出此消息，这可能表明省略了一些括号，从而导致潜在的有害行为。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0150</key>
    <name><![CDATA[最终块中的语句可能会吞下异常]]></name>
    <configKey>W0150</configKey>
    <description>
      <![CDATA[当在 try ... finally 块的 finally 子句中找到 break 或 return 语句时使用：try子句中引发的异常将被无声吞下，而不是重新引发。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0199</key>
    <name><![CDATA[在一个2-uple上使用调用了 assert]]></name>
    <configKey>W0199</configKey>
    <description>
      <![CDATA[如果元组（tuple）不为空，则对元组的 assert 调用将始终评估为true，如果为空，则将始终评估为false。 您是在表达“ assert x，y ”吗？]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0201</key>
    <name><![CDATA[在__init__外部定义属性]]></name>
    <configKey>W0201</configKey>
    <description>
      <![CDATA[在__init__方法之外定义实例属性时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0211</key>
    <name><![CDATA[以“ self ”或“ cls ”为第一个参数的静态方法]]></name>
    <configKey>W0211</configKey>
    <description>
      <![CDATA[当静态方法以“ self ”或在 valid-classmethod-first-arg 选项或 valid-metaclass-classmethod-first-arg 选项中指定的值作为第一个参数时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0212</key>
    <name><![CDATA[访问客户端类的受保护成员]]></name>
    <configKey>W0212</configKey>
    <description>
      <![CDATA[当受保护成员（即以下划线开头的名称的类成员）在类之外或在其定义的类的后代中访问时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0221</key>
    <name><![CDATA[参数数量存在差异]]></name>
    <configKey>W0221</configKey>
    <description>
      <![CDATA[当方法的参数数量与已实现的接口或重写的方法中的参数数量不同时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0222</key>
    <name><![CDATA[方法签名存在差异]]></name>
    <configKey>W0222</configKey>
    <description>
      <![CDATA[当方法签名不同于已实现的接口或重写的方法中时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0223</key>
    <name><![CDATA[抽象方法没有被覆盖]]></name>
    <configKey>W0223</configKey>
    <description>
      <![CDATA[在具体类中未覆盖抽象方法（即raise NotImplementedError）时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0231</key>
    <name><![CDATA[未调用基类的__init__方法]]></name>
    <configKey>W0231</configKey>
    <description>
      <![CDATA[当祖先类的方法具有 __init__ 方法但派生类未调用该方法时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0232</key>
    <name><![CDATA[类没有__init__方法]]></name>
    <configKey>W0232</configKey>
    <description>
      <![CDATA[当类既没有 __init__ 方法，也没有父类时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0233</key>
    <name><![CDATA[调用了来自非直接基类的__init__方法]]></name>
    <configKey>W0233</configKey>
    <description>
      <![CDATA[当调用了不属于所分析类的直接祖先的类上的__init__方法时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0234</key>
    <name><![CDATA[__iter__返回了不可迭代内容]]></name>
    <configKey>W0234</configKey>
    <description>
      <![CDATA[当 __iter__ 方法返回了不可迭代的内容时使用（即没有“ next ”方法）。
        <p>该规则在Pylint 1.1.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0235</key>
    <name><![CDATA[无用的super 代理（delegation）]]></name>
    <configKey>W0235</configKey>
    <description>
      <![CDATA[当我们检测到重写的方法无用时使用，它依赖super()代理（delegation）执行与MRO中的另一种方法相同的操作。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0301</key>
    <name><![CDATA[不必要的分号]]></name>
    <configKey>W0301</configKey>
    <description>
      <![CDATA[当语句以不需要的分号（“ ; ”）结束时使用（这是python，而不是C ;）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0311</key>
    <name><![CDATA[缩进存在问题]]></name>
    <configKey>W0311</configKey>
    <description>
      <![CDATA[当发现缩进的制表符或空格数量在意料之外时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0312</key>
    <name><![CDATA[制表符/空格混合缩进]]></name>
    <configKey>W0312</configKey>
    <description>
      <![CDATA[当模块中有一些混合的制表符和空格时使用。
               <p>由于缩进是Python语法的一部分，因此其用法的不一致
			   通常被认为是一个主要问题。</p>
      ]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>W0331</key>
    <name><![CDATA[使用 <> 运算符]]></name>
    <configKey>W0331</configKey>
    <description>
      <![CDATA[当使用不推荐使用的“ <> ”运算符而没有使用“ != ”时使用。
               <p>不建议使用此规则，可使用 {rule:python:InequalityUsage} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>W0332</key>
    <name><![CDATA[使用“ l ”作为长整数标识符]]></name>
    <configKey>W0332</configKey>
    <description>
      <![CDATA[当小写字母“ l ”用于标记长整数时使用。 您应该使用大写字母“ L ”，因为字母“ l ”看起来非常像数字“ 1 ”。当使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0333</key>
    <name><![CDATA[使用``运算符]]></name>
    <configKey>W0333</configKey>
    <description>
      <![CDATA[当使用不推荐使用的“ `` “（反引号）运算符代替 str() 函数时使用。
               <p>不建议使用此规则，可使用 {rule:python:BackticksUsage} 来代替。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>W0401</key>
    <name><![CDATA[导入通配符（wildcard）]]></name>
    <configKey>W0401</configKey>
    <description>
      <![CDATA[当检测到“from module import *”时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0402</key>
    <name><![CDATA[使用了不推荐使用的模块]]></name>
    <configKey>W0402</configKey>
    <description>
      <![CDATA[当导入了标记为已弃用的模块时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0403</key>
    <name><![CDATA[相对导入]]></name>
    <configKey>W0403</configKey>
    <description>
      <![CDATA[当检测到相对于软件包目录的导入时使用。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0404</key>
    <name><![CDATA[重复导入]]></name>
    <configKey>W0404</configKey>
    <description>
      <![CDATA[多次导入模块时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0406</key>
    <name><![CDATA[导入模块自身]]></name>
    <configKey>W0406</configKey>
    <description>
      <![CDATA[在模块自身导入时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0410</key>
    <name><![CDATA[__future__ import不是第一个非docstring语句]]></name>
    <configKey>W0410</configKey>
    <description>
      <![CDATA[Python 2.5及更高版本要求__future__ import是模块中的第一个非docstring语句。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0511</key>
    <name><![CDATA[找到任务标记]]></name>
    <configKey>W0511</configKey>
    <description>
      <![CDATA[当检测到警告提示为 FIXME 或 XXX 时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0512</key>
    <name><![CDATA[无法使用指定的源文件编码对源行进行解码]]></name>
    <configKey>W0512</configKey>
    <description>
      <![CDATA[当无法使用指定的源文件编码对源行进行解码时使用。 使用Python> = 3.0时不会发出此消息。
        <p>该规则在Pylint 1.0.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0601</key>
    <name><![CDATA[全局变量在模块级别中未定义]]></name>
    <configKey>W0601</configKey>
    <description>
      <![CDATA[当一个变量通过“global”语句定义但未在模块作用域中定义时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0602</key>
    <name><![CDATA[未分配的全局变量]]></name>
    <configKey>W0602</configKey>
    <description>
      <![CDATA[当一个变量通过“global”语句定义但未对其分配时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0603</key>
    <name><![CDATA[使用全局语句]]></name>
    <configKey>W0603</configKey>
    <description>
      <![CDATA[在使用“global”语句更新全局变量时使用。 Pylint只是试图阻止这种用法。 那并不意味着您不能使用它！]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0604</key>
    <name><![CDATA[在模块级别使用全局语句]]></name>
    <configKey>W0604</configKey>
    <description>
      <![CDATA[在模块级别使用“global”语句时使用，因为它是无效的。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0611</key>
    <name><![CDATA[未使用导入（import）]]></name>
    <configKey>W0611</configKey>
    <description>
      <![CDATA[当不使用导入的模块或变量时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0612</key>
    <name><![CDATA[未使用变量]]></name>
    <configKey>W0612</configKey>
    <description>
      <![CDATA[在定义了变量但未使用它时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0613</key>
    <name><![CDATA[未使用参数（argument）]]></name>
    <configKey>W0613</configKey>
    <description>
      <![CDATA[当不使用函数或方法参数时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0614</key>
    <name><![CDATA[使用的导入未通过通配符（wildcard）导入]]></name>
    <configKey>W0614</configKey>
    <description>
      <![CDATA[当未从''from X import *'样式导入中使用导入的模块或变量时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0621</key>
    <name><![CDATA[从外部范围重新定义名称]]></name>
    <configKey>W0621</configKey>
    <description>
      <![CDATA[当变量的名称隐藏外部作用域中定义的名称时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0622</key>
    <name><![CDATA[重新定义内置变量]]></name>
    <configKey>W0622</configKey>
    <description>
      <![CDATA[当变量或函数覆盖内置变量时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0623</key>
    <name><![CDATA[在异常处理程序中重新定义名称]]></name>
    <configKey>W0623</configKey>
    <description>
      <![CDATA[当异常处理程序将异常分配给现有名称时使用]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0631</key>
    <name><![CDATA[使用可能未定义的循环变量]]></name>
    <configKey>W0631</configKey>
    <description>
      <![CDATA[在循环外使用循环变量（即，由for循环或列表理解（list comprehension）或生成器表达式定义）时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0632</key>
    <name><![CDATA[可能存在不平衡的元组拆箱（tuple unpacking）]]></name>
    <configKey>W0632</configKey>
    <description>
      <![CDATA[在分配中存在不平衡的元组拆箱（tuple unpacking）时使用。
        <p>该规则在Pylint 1.1.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0633</key>
    <name><![CDATA[尝试拆开非序列包装]]></name>
    <configKey>W0633</configKey>
    <description>
      <![CDATA[在解包分配中使用了非序列的东西时使用。
        <p>该规则在Pylint 1.1.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0640</key>
    <name><![CDATA[循环中定义了单元变量]]></name>
    <configKey>W0640</configKey>
    <description>
      <![CDATA[闭包中使用的变量在循环中定义。 这将导致所有闭包对封闭变量使用相同的值。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0641</key>
    <name><![CDATA[可能存在未使用的变量]]></name>
    <configKey>W0641</configKey>
    <description>
      <![CDATA[在定义了变量但未使用时使用。 这种可能性来自可能使用locals()的事实，这可能消耗或不消耗所述变量。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0642</key>
    <name><![CDATA[方法中的分配无效]]></name>
    <configKey>W0642</configKey>
    <description>
      <![CDATA[分别在实例或类方法中对self或cls存在无效分配。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0701</key>
    <name><![CDATA[引发字符串异常]]></name>
    <configKey>W0701</configKey>
    <description>
      <![CDATA[当引发字符串异常时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0702</key>
    <name><![CDATA[未指定异常类型]]></name>
    <configKey>W0702</configKey>
    <description>
      <![CDATA[当except子句未指定要捕获的异常类型时使用。
               <p>捕获异常应尽可能精确。 可以引发的异常类型应该事先知道。 
			   使用catch-all-constructs会隐藏潜在的错误（包括语法错误），无法达到
			   了解所发生错误类型的目的，并无法使用定制的响应。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0703</key>
    <name><![CDATA[捕获到了太笼统的异常]]></name>
    <configKey>W0703</configKey>
    <description>
      <![CDATA[当except捕获到过于笼统的异常（可能掩埋无关的错误）时使用。
               <p>捕获异常应尽可能精确。 可以引发的异常类型应该事先知道。 
			   使用catch-all Exception实例无法达到了解所发生错误类型的目的，
			   并且无法使用定制的响应。</p>
      ]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0704</key>
    <name><![CDATA[except什么都不做]]></name>
    <configKey>W0704</configKey>
    <description>
      <![CDATA[当except子句仅执行“pass”并且没有“else”子句时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0705</key>
    <name><![CDATA[捕获到了先前捕获的异常类型]]></name>
    <configKey>W0705</configKey>
    <description>
      <![CDATA[当except捕获到了先前处理程序已经捕获的类型时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0706</key>
    <name><![CDATA[except处理程序立即引发异常]]></name>
    <configKey>W0706</configKey>
    <description>
      <![CDATA[当except处理程序使用raise作为其第一或唯一运算符时使用。 这是没有用的，因为它会立即引发异常。 删除raise运算符或整个try-except-raise块！]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0710</key>
    <name><![CDATA[异常没有从标准的“ Exception ”类继承]]></name>
    <configKey>W0710</configKey>
    <description>
      <![CDATA[当引发了一个自定义异常类但是该类没有继承自内置“ Exception ”类时使用。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0711</key>
    <name><![CDATA[捕获异常是二进制操作的结果]]></name>
    <configKey>W0711</configKey>
    <description>
      <![CDATA[当捕获的异常的格式为“ except A or B: ”时使用。 如果打算捕获多个，则重写为“ except(A, B): ”]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0712</key>
    <name><![CDATA[Python 3不支持隐式解包（implicit unpacking）异常]]></name>
    <configKey>W0712</configKey>
    <description>
      <![CDATA[Python3不允许在except子句中隐式解包（implicit unpacking）异常。
         请参阅http://www.python.org/dev/peps/pep-3110/  使用Python> = 3.0时不会发出此消息。
        <p>该规则在Pylint 1.0.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0715</key>
    <name><![CDATA[异常参数表明可能需要字符串格式化]]></name>
    <configKey>W0715</configKey>
    <description>
      <![CDATA[在将多个参数传递给异常构造函数时使用，它们中的第一个是包含要用于格式化的占位符的字符串文字。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W0716</key>
    <name><![CDATA[无效的异常操作]]></name>
    <configKey>W0716</configKey>
    <description>
      <![CDATA[当针对异常完成某项操作，但该操作对于所讨论的异常无效时使用。 通常在异常处理程序中的异常之间进行二进制运算时发出。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1001</key>
    <name><![CDATA[在旧式类上使用“ property ”]]></name>
    <configKey>W1001</configKey>
    <description>
      <![CDATA[当Pylint在旧式类上检测到依赖于新式类功能的内置“ property ”的使用时使用。 使用Python> = 3.0时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1111</key>
    <name><![CDATA[分配给仅返回None的函数调用]]></name>
    <configKey>W1111</configKey>
    <description>
      <![CDATA[在函数调用上完成赋值但推断的函数仅返回None时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1113</key>
    <name><![CDATA[可变位置参数列表之前定义关键字参数]]></name>
    <configKey>W1113</configKey>
    <description>
      <![CDATA[当在可变位置参数之前定义关键字参数时，可能会导致为上述参数传递多个值以防用关键字参数调用该方法。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1201</key>
    <name><![CDATA[指定字符串格式参数作为日志记录函数参数]]></name>
    <configKey>W1201</configKey>
    <description>
      <![CDATA[当记录语句的调用形式为“ logging.<logging method>(format_string % (format_args...)) ”时使用。 
	           这样的调用应将字符串插值（interpolation）留给日志记录方法本身，并写为“ logging.<logging method>(format_string,
               format_args...) ”，这样，在没有消息被记录的情况下，程序可以避免产生插值（interpolation）的消耗。
			   有关更多信息，请参见http://www.python.org/dev/peps/pep-0282/。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1202</key>
    <name><![CDATA[记录格式插值（interpolation）]]></name>
    <configKey>W1202</configKey>
    <description>
      <![CDATA[当日志记录语句的调用形式为“ logging.<logging method>(format_string.format(format_args...)) ”时使用。 这样的调用应改为使用 % 格式，但通过将参数作为参数传递将插值（interpolation）留给日志记录函数。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1203</key>
    <name><![CDATA[% 格式在日志记录功能中的使用]]></name>
    <configKey>W1203</configKey>
    <description>
      <![CDATA[当日志记录语句的调用形式为“ logging.method(f"...")) ”时使用。 这样的调用应改为 % 使用格式，但通过将参数作为参数传递将插值（interpolation）留给日志记录函数。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1300</key>
    <name><![CDATA[格式化字符串字典中键应为字符串]]></name>
    <configKey>W1300</configKey>
    <description>
      <![CDATA[当使用命名转换说明符的格式化字符串与键不是全部是字符串的字典一起使用时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1301</key>
    <name><![CDATA[格式化字符串字典中有未使用的键]]></name>
    <configKey>W1301</configKey>
    <description>
      <![CDATA[当使用命名转换说明符的格式化字符串与包含格式化字符串不需要的键的字典一起使用时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1302</key>
    <name><![CDATA[格式化字符串无效]]></name>
    <configKey>W1302</configKey>
    <description>
      <![CDATA[当PEP 3101格式化字符串无效时使用。 使用Python <2.7时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1303</key>
    <name><![CDATA[格式化字符串缺少关键字参数]]></name>
    <configKey>W1303</configKey>
    <description>
      <![CDATA[当使用命名字段的PEP 3101格式化字符串未收到一个或多个必需关键字时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1304</key>
    <name><![CDATA[未使用的格式参数]]></name>
    <configKey>W1304</configKey>
    <description>
      <![CDATA[当使用命名字段的PEP 3101格式化字符串与格式字符串不需要的参数一起使用时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1305</key>
    <name><![CDATA[格式化字符串同时包含自动字段编号和手动字段指定]]></name>
    <configKey>W1305</configKey>
    <description>
      <![CDATA[当PEP 3101格式化字符串同时包含自动字段编号（例如'{}'）和手动字段指定（例如'{0}'）时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1306</key>
    <name><![CDATA[缺少格式属性]]></name>
    <configKey>W1306</configKey>
    <description>
      <![CDATA[当PEP 3101格式化字符串使用属性说明符（{0.length}），但为格式化传递的参数不具有该属性时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1307</key>
    <name><![CDATA[在格式说明符中使用无效的查找键]]></name>
    <configKey>W1307</configKey>
    <description>
      <![CDATA[当PEP 3101格式化字符串使用查找说明符（{a[1]}），但为格式化传递的参数不包含该键或没有该键作为属性时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1308</key>
    <name><![CDATA[字符串格式化参数重复]]></name>
    <configKey>W1308</configKey>
    <description>
      <![CDATA[当检测到字符串格式化正在重复一个参数而不是使用命名的字符串参数时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1401</key>
    <name><![CDATA[反斜杠转义异常]]></name>
    <configKey>W1401</configKey>
    <description>
      <![CDATA[当反斜杠在文字字符串中但不用作转义符时使用。
      <p>该规则在Pylint 0.26.0中添加。</p>
      <p>不建议使用此规则，可使用 {rule:python:S1717} 来代替。</p>]]>
    </description>
    <priority>MINOR</priority>
    <status>DEPRECATED</status>
  </rule>
  <rule>
    <key>W1402</key>
    <name><![CDATA[字节字符串中的Unicode转义异常]]></name>
    <configKey>W1402</configKey>
    <description>
      <![CDATA[在字节串中遇到 \u 这样的转义符无效时使用。
      <p>该规则在Pylint 0.26.0中添加。</p>]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1403</key>
    <name><![CDATA[隐式字符串连接]]></name>
    <configKey>W1403</configKey>
    <description>
      <![CDATA[字符串literal在literal可迭代的定义中隐式连接：可能缺少逗号？]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1501</key>
    <name><![CDATA[无效的open模式]]></name>
    <configKey>W1501</configKey>
    <description>
      <![CDATA[Python支持带有b，+和U（仅带有r）选项的r，w，a [，x]模式。 参见http://docs.python.org/2/library/functions.html#open。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1502</key>
    <name><![CDATA[在布尔上下文中使用datetime.time。]]></name>
    <configKey>W1502</configKey>
    <description>
      <![CDATA[当布尔值表示的时间与午夜UTC时间匹配时，在布尔上下文中使用datetime.time可以隐藏细微的错误。 此行为已在Python 3.5中修复。 请参阅http://bugs.python.org/issue13936以获取参考。 使用Python> = 3.5时不会发出此消息。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1503</key>
    <name><![CDATA[unittest框架中assert冗余]]></name>
    <configKey>W1503</configKey>
    <description>
      <![CDATA[assertTrue 和 assertFalse 的第一个参数是一个条件。 如果将常量作为参数传递，则该条件将始终为 true。 在这种情况下，应该发出警告。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1505</key>
    <name><![CDATA[使用了不推荐使用的方法]]></name>
    <configKey>W1505</configKey>
    <description>
      <![CDATA[该方法被标记为已弃用，并将在将来的Python版本中删除。 考虑在文档中寻找替代方案。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1506</key>
    <name><![CDATA[threading.Thread 需要目标函数]]></name>
    <configKey>W1506</configKey>
    <description>
      <![CDATA[当实例化 threading.Thread 类而未传递目标函数时，发出警告。 默认情况下，第一个参数是组（group）参数，而不是目标参数。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1507</key>
    <name><![CDATA[使用了copy.copy(os.environ)。建议使用os.environ.copy()来代替。]]></name>
    <configKey>W1507</configKey>
    <description>
      <![CDATA[os.environ 不是字典对象，而是代理对象，因此浅拷贝（shallow copy）仍然会对原始对象产生影响。 请参阅https://bugs.python.org/issue15373以获取参考。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1508</key>
    <name><![CDATA[Env操作函数（manipulation functions）中的类型无效]]></name>
    <configKey>W1508</configKey>
    <description>
      <![CDATA[Env操作函数（manipulation functions）返回 None 或 str 值。 默认提供任何其他内容都可能导致错误。 参见https://docs.python.org/3/library/os.html#os.getenv。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1509</key>
    <name><![CDATA[在存在线程的情况下使用 preexec_fn 关键字可能不安全]]></name>
    <configKey>W1509</configKey>
    <description>
      <![CDATA[如果您的程序中存在线程，则 preexec_fn 参数并不能安全使用。 在调用 exec 之前，子进程可能会死锁。 如果不是必须使用它，请尽量不要使用！ 最小化您要调用的库的数量。https://docs.python.org/3/library/subprocess.html#popen-constructor。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1601</key>
    <name><![CDATA[引用了 apply 内置函数]]></name>
    <configKey>W1601</configKey>
    <description>
      <![CDATA[当引用了 apply 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1602</key>
    <name><![CDATA[引用了 basestring 内置函数]]></name>
    <configKey>W1602</configKey>
    <description>
      <![CDATA[当引用了 basestring 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1603</key>
    <name><![CDATA[引用了 buffer 内置函数]]></name>
    <configKey>W1603</configKey>
    <description>
      <![CDATA[当引用了 buffer 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1604</key>
    <name><![CDATA[引用了 cmp 内置函数]]></name>
    <configKey>W1604</configKey>
    <description>
      <![CDATA[当引用了 cmp 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1605</key>
    <name><![CDATA[引用了 coerce 内置函数]]></name>
    <configKey>W1605</configKey>
    <description>
      <![CDATA[当引用了 coerce 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1606</key>
    <name><![CDATA[引用了 execfile 内置函数]]></name>
    <configKey>W1606</configKey>
    <description>
      <![CDATA[当引用了 execfile 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1607</key>
    <name><![CDATA[引用了 file 内置函数]]></name>
    <configKey>W1607</configKey>
    <description>
      <![CDATA[当引用了 file 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1608</key>
    <name><![CDATA[引用了 long 内置函数]]></name>
    <configKey>W1608</configKey>
    <description>
      <![CDATA[当引用了 long 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1609</key>
    <name><![CDATA[引用了 raw_input 内置函数]]></name>
    <configKey>W1609</configKey>
    <description>
      <![CDATA[当引用了 raw_input 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1610</key>
    <name><![CDATA[引用了 reduce 内置函数]]></name>
    <configKey>W1610</configKey>
    <description>
      <![CDATA[当引用了 reduce 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1611</key>
    <name><![CDATA[引用了 StandardError 内置函数]]></name>
    <configKey>W1611</configKey>
    <description>
      <![CDATA[当引用了 StandardError 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1612</key>
    <name><![CDATA[引用了 unicode 内置函数]]></name>
    <configKey>W1612</configKey>
    <description>
      <![CDATA[当引用了 unicode 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1613</key>
    <name><![CDATA[引用了 xrange 内置函数]]></name>
    <configKey>W1613</configKey>
    <description>
      <![CDATA[当引用了 xrange 内置函数时使用（Python 3缺少此函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1614</key>
    <name><![CDATA[定义了__coerce__方法]]></name>
    <configKey>W1614</configKey>
    <description>
      <![CDATA[在定义__coerce__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1615</key>
    <name><![CDATA[定义了__delslice__方法]]></name>
    <configKey>W1615</configKey>
    <description>
      <![CDATA[在定义__delslice__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1616</key>
    <name><![CDATA[定义了__getslice__方法]]></name>
    <configKey>W1616</configKey>
    <description>
      <![CDATA[在定义__getslice__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1617</key>
    <name><![CDATA[定义了__setslice__方法]]></name>
    <configKey>W1617</configKey>
    <description>
      <![CDATA[在定义__setslice__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1618</key>
    <name><![CDATA[导入（import）时缺少 `from __future__ import absolute_import`]]></name>
    <configKey>W1618</configKey>
    <description>
      <![CDATA[当导入（import）没有 ``from __future__ import absolute_import`` 时使用（Python 3中的默认行为）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1619</key>
    <name><![CDATA[使用精准除法没有使用 __future__ 语句]]></name>
    <configKey>W1619</configKey>
    <description>
      <![CDATA[当没有使用 floor 语句的除法没有使用浮点型字符或者没有``from __future__ import division``时使用（Python 3在无条件时对于 int 精准除法返回浮点数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1620</key>
    <name><![CDATA[调用了 dict.iter*() 方法]]></name>
    <configKey>W1620</configKey>
    <description>
      <![CDATA[当调用了 dict.iterkeys()，itervalues()或iteritems()时使用（Python 3缺少这些方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1621</key>
    <name><![CDATA[调用了 dict.view*() 方法]]></name>
    <configKey>W1621</configKey>
    <description>
      <![CDATA[当调用了 dict.viewkeys()，viewvalues()或viewitems()时使用（Python 3缺少这些方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1622</key>
    <name><![CDATA[在对象上调用了next()方法]]></name>
    <configKey>W1622</configKey>
    <description>
      <![CDATA[当调用了对象的 next()方法时使用（Python 3使用next()内置函数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1623</key>
    <name><![CDATA[分配给类的__metaclass__属性]]></name>
    <configKey>W1623</configKey>
    <description>
      <![CDATA[当通过分配给__metaclass__来指定 metaclass 类时使用（Python 3将 metaclass 指定为类声明参数）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1624</key>
    <name><![CDATA[索引异常不适用于Python 3]]></name>
    <configKey>W1624</configKey>
    <description>
      <![CDATA[索引异常不适用于Python3。请改用`exception.args [index]`。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1625</key>
    <name><![CDATA[引发了字符串异常]]></name>
    <configKey>W1625</configKey>
    <description>
      <![CDATA[当引发了字符串异常时使用。 这不适用于Python 3。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1626</key>
    <name><![CDATA[引用了 reload 内置函数]]></name>
    <configKey>W1626</configKey>
    <description>
      <![CDATA[当引用了 reload 内置函数时使用（Python 3缺少此函数）。 您可以改用 imp.reload 或 importlib.reload。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1627</key>
    <name><![CDATA[定义了__oct__方法]]></name>
    <configKey>W1627</configKey>
    <description>
      <![CDATA[在定义__oct__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1628</key>
    <name><![CDATA[定义了__hex__方法]]></name>
    <configKey>W1628</configKey>
    <description>
      <![CDATA[在定义__hex__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1629</key>
    <name><![CDATA[定义了__nonzero__方法]]></name>
    <configKey>W1629</configKey>
    <description>
      <![CDATA[在定义__nonzero__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1630</key>
    <name><![CDATA[定义了__cmp__方法]]></name>
    <configKey>W1630</configKey>
    <description>
      <![CDATA[在定义__cmp__方法时使用（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1632</key>
    <name><![CDATA[引用了 input 内置函数]]></name>
    <configKey>W1632</configKey>
    <description>
      <![CDATA[当引用了 input 内置函数时使用（Python 3为向后不兼容语义（backwards-incompatible semantics））。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1633</key>
    <name><![CDATA[引用了 round 内置函数]]></name>
    <configKey>W1633</configKey>
    <description>
      <![CDATA[当引用了 round 内置函数时使用（Python 3为向后不兼容语义（backwards-incompatible semantics））。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1634</key>
    <name><![CDATA[引用了 intern 内置函数]]></name>
    <configKey>W1634</configKey>
    <description>
      <![CDATA[当引用了 intern 内置函数时使用（在Python 3中已移至sys.intern）]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1635</key>
    <name><![CDATA[引用了 unichr 内置函数]]></name>
    <configKey>W1635</configKey>
    <description>
      <![CDATA[当引用了 unichr 内置函数时使用（在Python 3中请使用chr）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1636</key>
    <name><![CDATA[在非迭代时引用了 map 内置函数]]></name>
    <configKey>W1636</configKey>
    <description>/
      <![CDATA[在非迭代上下文中引用了 map 内置函数时使用（在Python 3中返回迭代器）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1637</key>
    <name><![CDATA[在非迭代时引用了 zip 内置函数]]></name>
    <configKey>W1637</configKey>
    <description>
      <![CDATA[在非迭代上下文中引用了 zip 内置函数时使用（在Python 3中返回迭代器）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1638</key>
    <name><![CDATA[在非迭代时引用了 range 内置函数]]></name>
    <configKey>W1638</configKey>
    <description>
      <![CDATA[在非迭代上下文中引用了 range 内置函数时使用（在Python 3中返回迭代器）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1639</key>
    <name><![CDATA[在非迭代时引用了 filter 内置函数 ]]></name>
    <configKey>W1639</configKey>
    <description>
      <![CDATA[在非迭代上下文中引用 filter 内置函数时使用（在Python 3中返回迭代器）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1640</key>
    <name><![CDATA[将 cmp 参数用于 list.sort / sorted]]></name>
    <configKey>W1640</configKey>
    <description>
      <![CDATA[应该避免将 cmp 参数用于 list.sort 或 sorted 内置函数，因为它已在Python 3中删除。应该首选使用 `key` 或 `functools.cmp_to_key` 。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1641</key>
    <name><![CDATA[实现__eq__时并没有实现__hash__]]></name>
    <configKey>W1641</configKey>
    <description>
      <![CDATA[当类实现__eq__而不是__hash__时使用。 在Python 2中，对象获取 object.__ hash__ 作为默认实现，在Python 3中，如果对象也实现__eq__，
	  则获取 None 作为其默认__hash__实现。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1642</key>
    <name><![CDATA[定义了__div__方法]]></name>
    <configKey>W1642</configKey>
    <description>
      <![CDATA[在定义__div__方法时使用。 最好使用 `__truediv__` 并设置 __div__ = __truediv__（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1643</key>
    <name><![CDATA[定义了__idiv__方法]]></name>
    <configKey>W1643</configKey>
    <description>
      <![CDATA[在定义__idiv__方法时使用。 最好使用 `__itruediv__` 并设置 __idiv__ = __itruediv__（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1644</key>
    <name><![CDATA[定义了__rdiv__方法]]></name>
    <configKey>W1644</configKey>
    <description>
      <![CDATA[在定义__rdiv__方法时使用。 最好使用 `__rtruediv__` 并设置 __rdivdiv = __rtruediv__（Python 3不使用该方法）。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1645</key>
    <name><![CDATA[在Python 3中删除了 Exception.message]]></name>
    <configKey>W1645</configKey>
    <description>
      <![CDATA[在 Exception 上访问 message 属性时使用。请使用 str(exception)来代替。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1646</key>
    <name><![CDATA[str.decode 中使用了非文本编码（non-text encoding）]]></name>
    <configKey>W1646</configKey>
    <description>
      <![CDATA[在将 str.encode 或 str.decode 与非文本编码（non-text encoding）一起使用时使用。使用 codecs 模块来处理任意 codecs。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1647</key>
    <name><![CDATA[在python 3中删除了sys.maxint]]></name>
    <configKey>W1647</configKey>
    <description>
      <![CDATA[在访问 sys.maxint 时使用。请改用sys.maxsize。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1649</key>
    <name><![CDATA[访问字符串模块上不推荐使用的函数]]></name>
    <configKey>W1649</configKey>
    <description>
      <![CDATA[在访问Python 3中已弃用的字符串函数时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1650</key>
    <name><![CDATA[使用了带有不推荐使用的 deletechars 参数的 str.translate]]></name>
    <configKey>W1650</configKey>
    <description>
      <![CDATA[当使用了 str.translate 中不推荐使用的 deletechars 参数时使用。 可使用 re.sub 删除字符。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1651</key>
    <name><![CDATA[访问 itertools 模块上已弃用的函数]]></name>
    <configKey>W1651</configKey>
    <description>
      <![CDATA[当访问已在Python 3中删除的 itertools 上的函数时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1652</key>
    <name><![CDATA[访问 types 模块上已弃用的字段]]></name>
    <configKey>W1652</configKey>
    <description>
      <![CDATA[当访问已在Python 3中删除的 types 中的字段时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1653</key>
    <name><![CDATA[定义了 next 方法]]></name>
    <configKey>W1653</configKey>
    <description>
      <![CDATA[在定义了在Python 2中是迭代器但在Python 3中被视为普通函数的 next 方法时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1654</key>
    <name><![CDATA[在非迭代中引用了dict.items]]></name>
    <configKey>W1654</configKey>
    <description>
      <![CDATA[当在非迭代上下文中引用 dict.items 时使用（在Python 3中返回迭代器）]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1655</key>
    <name><![CDATA[在非迭代中引用了dict.keys]]></name>
    <configKey>W1655</configKey>
    <description>
      <![CDATA[当在非迭代上下文中引用 dict.keys 时使用（在Python 3中返回迭代器）]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1656</key>
    <name><![CDATA[在非迭代中引用了dict.values]]></name>
    <configKey>W1656</configKey>
    <description>
      <![CDATA[当在非迭代上下文中引用了 dict.values 时使用（在Python 3中返回迭代器）]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1657</key>
    <name><![CDATA[访问 operator 模块上的已删除属性]]></name>
    <configKey>W1657</configKey>
    <description>
      <![CDATA[当访问已在Python 3中删除的 operator 模块上的字段时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1658</key>
    <name><![CDATA[访问 urllib 模块上的已删除属性]]></name>
    <configKey>W1658</configKey>
    <description>
      <![CDATA[当访问已在Python 3中移除或移动的 urllib 模块上的字段时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1659</key>
    <name><![CDATA[访问已删除的 xreadlines 属性]]></name>
    <configKey>W1659</configKey>
    <description>
      <![CDATA[当访问文件流上的 xreadlines() 函数时使用，其已在Python 3中删除。]]>
    </description>
    <priority>MAJOR</priority>
  </rule>
  <rule>
    <key>W1660</key>
    <name><![CDATA[访问 sys 模块上的已删除属性]]></name>
    <configKey>W1660</configKey>
    <description>
      <![CDATA[当访问已在Python 3中删除的 sys 模块上的字段时使用。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1661</key>
    <name><![CDATA[使用了由异常处理程序绑定的异常对象]]></name>
    <configKey>W1661</configKey>
    <description>
      <![CDATA[当一个绑定在异常处理程序的内异常，在异常处理程序之外使用时发出。 在Python 3中，一旦这些异常脱离了异常处理程序，它们将被删除。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
  <rule>
    <key>W1662</key>
    <name><![CDATA[使用绑定在解析（comprehension）范围内的变量Using a variable that was bound inside a comprehension]]></name>
    <configKey>W1662</configKey>
    <description>
      <![CDATA[当一个绑定在解析（comprehension)处理程序内的变量，在解析（comprehension）处理程序之外使用时发出。 
	  在Python 3中，一旦这些变量在解析（comprehension）之外，它们将被删除。]]>
    </description>
    <priority>MINOR</priority>
  </rule>
</rules>
