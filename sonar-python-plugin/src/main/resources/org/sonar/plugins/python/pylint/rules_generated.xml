<?xml version="1.0" encoding="ASCII"?>
<rules>
<rule>
<key>C0102</key>
<name><![CDATA[黑名单名称"%s"]]></name>
<configKey>C0102</configKey>
<description>
<![CDATA[该名称在黑名单中列出时才使用（未经授权的名称）。]]>
</description>
</rule>
<rule>
<key>C0103</key>
<name><![CDATA[%s名称"%s"不符合%s]]></name>
<configKey>C0103</configKey>
<description>
<![CDATA[当名称不符合与其类型（constant, variable, class...）相关的命名规则时使用。]]>
</description>
</rule>
<rule>
<key>C0111</key>
<name><![CDATA[缺少%s文档字符串]]></name>
<configKey>C0111</configKey>
<description>
<![CDATA[当模块，函数，类或方法没有文档字符串时使用.__ init__之类的一些特殊方法不需要文档字符串。]]>
</description>
</rule>
<rule>
<key>C0112</key>
<name><![CDATA[空的%s文档字符串]]></name>
<configKey>C0112</configKey>
<description>
<![CDATA[当模块，函数，类或方法中有空文档字符串时使用（这太容易了；）。]]>
</description>
</rule>
<rule>
<key>C0113</key>
<name><![CDATA[考虑将"%s"更改为"%s"]]></name>
<configKey>C0113</configKey>
<description>
<![CDATA[当布尔表达式包含不需要的否定时使用。]]>
</description>
</rule>
<rule>
<key>C0121</key>
<name><![CDATA[与%s的比较应为%s]]></name>
<configKey>C0121</configKey>
<description>
<![CDATA[在将表达式与True，False或None等单例值进行比较时使用。]]>
</description>
</rule>
<rule>
<key>C0122</key>
<name><![CDATA[比较应该是%s]]></name>
<configKey>C0122</configKey>
<description>
<![CDATA[当常量位于比较的左侧时使用。 通常将其放置在比较的右侧更加清楚。]]>
</description>
</rule>
<rule>
<key>C0123</key>
<name><![CDATA[使用type()代替isinstance()进行类型检查。]]></name>
<configKey>C0123</configKey>
<description>
<![CDATA[在Python中执行显式类型检查的惯用方式是使用isinstance(x, Y)而不是type(x) == Y, type(x) 为 Y。尽管在某些特殊情况下，它们会给出不同的结果。]]>
</description>
</rule>
<rule>
<key>C0200</key>
<name><![CDATA[考虑使用枚举而不是使用range和len进行迭代]]></name>
<configKey>C0200</configKey>
<description>
<![CDATA[当遇到用range和len进行迭代的代码时发出。 可以通过使用内置枚举来简化此类代码。]]>
</description>
</rule>
<rule>
<key>C0201</key>
<name><![CDATA[考虑直接迭代字典，而不是调用.keys()]]></name>
<configKey>C0201</configKey>
<description>
<![CDATA[通过.keys()方法所迭代字典的键时发出。只需迭代字典本身就足够了，如"for key in dictionary"中所示。]]>
</description>
</rule>
<rule>
<key>C0202</key>
<name><![CDATA[类方法%s应该以%s作为第一个参数]]></name>
<configKey>C0202</configKey>
<description>
<![CDATA[当类方法的第一个参数的名称与valid-classmethod-first-arg选项中指定的值（默认值为“ cls”）不同时，使用该参数，建议您将其与常规实例方法区分开。]]>
</description>
</rule>
<rule>
<key>C0203</key>
<name><![CDATA[元类方法%s应该以%s作为第一个参数]]></name>
<configKey>C0203</configKey>
<description>
<![CDATA[当元类方法的第一个参数的名称与valid-classmethod-first-arg选项中指定的值（默认值为“ cls”）不同时，使用该参数，建议您将其与常规实例方法区分开。]]>
</description>
</rule>
<rule>
<key>C0204</key>
<name><![CDATA[元类类方法%s应该以%s作为第一个参数]]></name>
<configKey>C0204</configKey>
<description>
<![CDATA[当元类类方法的第一个参数的名称与valid-metaclass-classmethod-first-arg选项中指定的值（默认为“ mcs”）不同时，使用该参数，建议您将其与常规实例方法区分开。]]>
</description>
</rule>
<rule>
<key>C0205</key>
<name><![CDATA[类__slots__应该是非字符串可迭代的]]></name>
<configKey>C0205</configKey>
<description>
<![CDATA[当类__slots__是简单字符串而不是可迭代字符串时使用。]]>
</description>
</rule>
<rule>
<key>C0301</key>
<name><![CDATA[行太长(%s/%s)]]></name>
<configKey>C0301</configKey>
<description>
<![CDATA[当一行超过给定字符数时使用。]]>
</description>
</rule>
<rule>
<key>C0302</key>
<name><![CDATA[模块中的行太多(%s/%s)]]></name>
<configKey>C0302</configKey>
<description>
<![CDATA[当模块的行数过多以至于降低了其可读性时使用。]]>
</description>
</rule>
<rule>
<key>C0303</key>
<name><![CDATA[行尾空格]]></name>
<configKey>C0303</configKey>
<description>
<![CDATA[当行尾和换行符之间有空格时使用。]]>
</description>
</rule>
<rule>
<key>C0304</key>
<name><![CDATA[最终换行符丢失]]></name>
<configKey>C0304</configKey>
<description>
<![CDATA[当文件的最后一行缺少换行符时使用。]]>
</description>
</rule>
<rule>
<key>C0305</key>
<name><![CDATA[行尾换行符]]></name>
<configKey>C0305</configKey>
<description>
<![CDATA[当文件的末尾有空白行时使用。]]>
</description>
</rule>
<rule>
<key>C0321</key>
<name><![CDATA[一行有多个语句]]></name>
<configKey>C0321</configKey>
<description>
<![CDATA[当在同一行上找到多于一条语句时使用。]]>
</description>
</rule>
<rule>
<key>C0325</key>
<name><![CDATA[%r关键字后不必要的括号]]></name>
<configKey>C0325</configKey>
<description>
<![CDATA[当括号中的单个项目后接if，for或其他关键字时使用。]]>
</description>
</rule>
<rule>
<key>C0326</key>
<name><![CDATA[%s空格%s %s %s]]></name>
<configKey>C0326</configKey>
<description>
<![CDATA[当在运算符，括号或块开始符周围使用错误数量的空格时使用。]]>
</description>
</rule>
<rule>
<key>C0327</key>
<name><![CDATA[混合行结尾LF和CRLF]]></name>
<configKey>C0327</configKey>
<description>
<![CDATA[当文件中包含混合（LF和CRLF）换行符时使用。]]>
</description>
</rule>
<rule>
<key>C0328</key>
<name><![CDATA[意外的行结束格式。 存在'%s'，而应为'%s'。]]></name>
<configKey>C0328</configKey>
<description>
<![CDATA[当换行符与预期的不同时使用。]]>
</description>
</rule>
<rule>
<key>C0330</key>
<name><![CDATA[%s缩进错误%s%s。]]></name>
<configKey>C0330</configKey>
<description>
<![CDATA[TODO]]>
</description>
</rule>
<rule>
<key>C0401</key>
<name><![CDATA[注释中单词'%s'的拼写错误：]]></name>
<configKey>C0401</configKey>
<description>
<![CDATA[当注释中的单词拼写不正确时使用。]]>
</description>
</rule>
<rule>
<key>C0402</key>
<name><![CDATA[文档字符串中单词'%s'的拼写错误：]]></name>
<configKey>C0402</configKey>
<description>
<![CDATA[当文档字符串中的单词拼写不正确时使用。]]>
</description>
</rule>
<rule>
<key>C0403</key>
<name><![CDATA[文档字符串中的无效字符%r]]></name>
<configKey>C0403</configKey>
<description>
<![CDATA[当enchant无法检查文档字符串中的单词时使用。]]>
</description>
</rule>
<rule>
<key>C0410</key>
<name><![CDATA[一行上有多个导入(%s)]]></name>
<configKey>C0410</configKey>
<description>
<![CDATA[当检测到导入语句导入多个模块时使用。]]>
</description>
</rule>
<rule>
<key>C0411</key>
<name><![CDATA[%s应该放在%s之前]]></name>
<configKey>C0411</configKey>
<description>
<![CDATA[在不遵守PEP8导入顺序时使用（首先是标准导入，然后是第三方库，然后是本地导入）]]>
</description>
</rule>
<rule>
<key>C0412</key>
<name><![CDATA[来自软件包％s的导入未分组]]></name>
<configKey>C0412</configKey>
<description>
<![CDATA[当导入未按包分组时使用]]>
</description>
</rule>
<rule>
<key>C0413</key>
<name><![CDATA[导入"%s"应放在模块顶部]]></name>
<configKey>C0413</configKey>
<description>
<![CDATA[在代码和导入混合使用时使用]]>
</description>
</rule>
<rule>
<key>C0414</key>
<name><![CDATA[导入别名不会重命名原始包]]></name>
<configKey>C0414</configKey>
<description>
<![CDATA[当导入别名与原始软件包相同时使用，例如使用导入numpy作为numpy而不是导入numpy作为np。]]>
</description>
</rule>
<rule>
<key>C1801</key>
<name><![CDATA[不要使用`len(SEQUENCE)`来确定序列是否为空]]></name>
<configKey>C1801</configKey>
<description>
<![CDATA[当Pylint检测到在条件内部使用len(sequence)来确定序列是否为空时使用。 不用将长度与0进行比较，而是依靠空序列为假的事实。]]>
</description>
</rule>
<rule>
<key>E0001</key>
<name><![CDATA[]]></name>
<configKey>E0001</configKey>
<description>
<![CDATA[当模块出现语法错误时使用。]]>
</description>
</rule>
<rule>
<key>E0011</key>
<name><![CDATA[无法识别的文件选项%r]]></name>
<configKey>E0011</configKey>
<description>
<![CDATA[在遇到未知的内联选项时使用。]]>
</description>
</rule>
<rule>
<key>E0012</key>
<name><![CDATA[错误的选项值%r]]></name>
<configKey>E0012</configKey>
<description>
<![CDATA[当遇到内联选项的错误值时使用。]]>
</description>
</rule>
<rule>
<key>E0100</key>
<name><![CDATA[__init__方法是一个生成器]]></name>
<configKey>E0100</configKey>
<description>
<![CDATA[当特殊类方法__init__通过其主体中的yield转换为生成器时使用。]]>
</description>
</rule>
<rule>
<key>E0101</key>
<name><![CDATA[__init__中的显式返回]]></name>
<configKey>E0101</configKey>
<description>
<![CDATA[当特殊类方法__init__具有显式的返回值时使用。]]>
</description>
</rule>
<rule>
<key>E0102</key>
<name><![CDATA[%s已定义第%s行]]></name>
<configKey>E0102</configKey>
<description>
<![CDATA[在重新定义函数/类/方法时使用。]]>
</description>
</rule>
<rule>
<key>E0103</key>
<name><![CDATA[%r无法正确循环]]></name>
<configKey>E0103</configKey>
<description>
<![CDATA[在循环外使用break或continue关键字时使用。]]>
</description>
</rule>
<rule>
<key>E0104</key>
<name><![CDATA[返回外部函数]]></name>
<configKey>E0104</configKey>
<description>
<![CDATA[在函数或方法之外找到"return"语句时使用。]]>
</description>
</rule>
<rule>
<key>E0105</key>
<name><![CDATA[函数外找到Yield]]></name>
<configKey>E0105</configKey>
<description>
<![CDATA[在函数或方法之外找到"yield"语句时使用。]]>
</description>
</rule>
<rule>
<key>E0107</key>
<name><![CDATA[使用不存在的%s运算符]]></name>
<configKey>E0107</configKey>
<description>
<![CDATA[当尝试使用C样式的预增或预减运算符--和++（在Python中不存在）时使用。]]>
</description>
</rule>
<rule>
<key>E0108</key>
<name><![CDATA[函数定义中的参数名%s重复]]></name>
<configKey>E0108</configKey>
<description>
<![CDATA[函数定义中重复的参数名称是语法错误。]]>
</description>
</rule>
<rule>
<key>E0110</key>
<name><![CDATA[实例化具有抽象方法的抽象类%r]]></name>
<configKey>E0110</configKey>
<description>
<![CDATA[当以`abc.ABCMeta`作为元类的抽象类具有抽象方法并被实例化时使用。]]>
</description>
</rule>
<rule>
<key>E0111</key>
<name><![CDATA[reversed()的第一个参数不是序列]]></name>
<configKey>E0111</configKey>
<description>
<![CDATA[当内置的reversed()的第一个参数不是序列时(既不实现__reversed__，也不实现__getitem__ 和 __len__）使用。]]>
</description>
</rule>
<rule>
<key>E0112</key>
<name><![CDATA[作业中有多个加注星标的表达式]]></name>
<configKey>E0112</configKey>
<description>
<![CDATA[当一个作业中有多个加星标的表达式(`*x`) 时发出。这是一个语法错误。]]>
</description>
</rule>
<rule>
<key>E0113</key>
<name><![CDATA[加星标的赋值目标必须在列表或元组中]]></name>
<configKey>E0113</configKey>
<description>
<![CDATA[当星号表达式用作带星号的赋值目标时发出。]]>
</description>
</rule>
<rule>
<key>E0114</key>
<name><![CDATA[只能在赋值目标中使用加星标的表达式。]]></name>
<configKey>E0114</configKey>
<description>
<![CDATA[在赋值目标中未使用星号表达式时发出。]]>
</description>
</rule>
<rule>
<key>E0115</key>
<name><![CDATA[名称%r是非本地和全局的]]></name>
<configKey>E0115</configKey>
<description>
<![CDATA[当名称同时是非本地和全局名称时发出。]]>
</description>
</rule>
<rule>
<key>E0116</key>
<name><![CDATA['finally'子句中不支持'continue']]></name>
<configKey>E0116</configKey>
<description>
<![CDATA[在finally子句中发现`continue`关键字时发出，这是一个语法错误。]]>
</description>
</rule>
<rule>
<key>E0117</key>
<name><![CDATA[找到未绑定的非本地名称%s]]></name>
<configKey>E0117</configKey>
<description>
<![CDATA[当非局部变量在父作用域中没有附加名称时发出。]]>
</description>
</rule>
<rule>
<key>E0119</key>
<name><![CDATA[在str上未调用format函数]]></name>
<configKey>E0119</configKey>
<description>
<![CDATA[在str对象上未调用format函数时发出。例如执行print("value: {}").format(123)而不是print("value: {}".format(123))。这可能不是您想要的。]]>
</description>
</rule>
<rule>
<key>E0202</key>
<name><![CDATA[%s行%s中定义的属性隐藏了此方法。]]></name>
<configKey>E0202</configKey>
<description>
<![CDATA[当类定义一个方法时，该方法被祖先类的实例属性隐藏或由某些客户端代码设置时使用。]]>
</description>
</rule>
<rule>
<key>E0203</key>
<name><![CDATA[在其定义行%s之前可以访问成员%r]]></name>
<configKey>E0203</configKey>
<description>
<![CDATA[在实例成员被实际分配之前对其进行访问时使用。]]>
</description>
</rule>
<rule>
<key>E0211</key>
<name><![CDATA[方法没有参数]]></name>
<configKey>E0211</configKey>
<description>
<![CDATA[当应该将绑定实例作为第一个参数的方法未定义参数时使用。]]>
</description>
</rule>
<rule>
<key>E0213</key>
<name><![CDATA[方法应以"self"作为第一个参数]]></name>
<configKey>E0213</configKey>
<description>
<![CDATA[当方法的属性作为第一个参数具有与"self"不同的属性时使用。 这被认为是错误的，因为这是非常常见的规定，您不应该破坏它！]]>
</description>
</rule>
<rule>
<key>E0236</key>
<name><![CDATA[__slots__中的无效对象%r必须仅包含非空字符串]]></name>
<configKey>E0236</configKey>
<description>
<![CDATA[当 __slots__中出现无效（非字符串）对象时使用。]]>
</description>
</rule>
<rule>
<key>E0237</key>
<name><![CDATA[分配给在类slots中未定义的属性%r]]></name>
<configKey>E0237</configKey>
<description>
<![CDATA[当分配给未在类slots中定义的属性时使用。]]>
</description>
</rule>
<rule>
<key>E0238</key>
<name><![CDATA[无效的__slots__对象]]></name>
<configKey>E0238</configKey>
<description>
<![CDATA[在类中发现无效的__slots__是使用。仅允许使用字符串，iterable或序列。]]>
</description>
</rule>
<rule>
<key>E0239</key>
<name><![CDATA[继承%r,这不是一个类]]></name>
<configKey>E0239</configKey>
<description>
<![CDATA[当类从非类继承时使用。]]>
</description>
</rule>
<rule>
<key>E0240</key>
<name><![CDATA[类%r的方法解析顺序不一致]]></name>
<configKey>E0240</configKey>
<description>
<![CDATA[当类的方法解析顺序不一致时使用。]]>
</description>
</rule>
<rule>
<key>E0241</key>
<name><![CDATA[类%r的duplicate bases]]></name>
<configKey>E0241</configKey>
<description>
<![CDATA[当一个类具有duplicate bases时使用。]]>
</description>
</rule>
<rule>
<key>E0301</key>
<name><![CDATA[__iter__返回非迭代器]]></name>
<configKey>E0301</configKey>
<description>
<![CDATA[当__iter__方法返回不可迭代的内容时使用(即没有`__next__`方法)]]>
</description>
</rule>
<rule>
<key>E0302</key>
<name><![CDATA[特殊方法%r需要%s个参数，给定%d %s]]></name>
<configKey>E0302</configKey>
<description>
<![CDATA[当使用无效数目的参数定义特殊方法时发出。 如果数量太少或太多，则可能根本无法工作。]]>
</description>
</rule>
<rule>
<key>E0303</key>
<name><![CDATA[__len__不返回非负整数]]></name>
<configKey>E0303</configKey>
<description>
<![CDATA[当__len__方法返回不是非负整数的值时使用]]>
</description>
</rule>
<rule>
<key>E0401</key>
<name><![CDATA[无法导入%s]]></name>
<configKey>E0401</configKey>
<description>
<![CDATA[当pylint无法导入模块时使用]]>
</description>
</rule>
<rule>
<key>E0402</key>
<name><![CDATA[尝试在顶级包之外进行相对导入]]></name>
<configKey>E0402</configKey>
<description>
<![CDATA[当相对导入尝试访问当前包中的太多级别时使用。]]>
</description>
</rule>
<rule>
<key>E0601</key>
<name><![CDATA[分配前使用变量%r]]></name>
<configKey>E0601</configKey>
<description>
<![CDATA[在分配前访问局部变量时使用。]]>
</description>
</rule>
<rule>
<key>E0602</key>
<name><![CDATA[未定义的变量%r]]></name>
<configKey>E0602</configKey>
<description>
<![CDATA[在访问未定义的变量时使用。]]>
</description>
</rule>
<rule>
<key>E0603</key>
<name><![CDATA[__all__中的未定义变量名%r]]></name>
<configKey>E0603</configKey>
<description>
<![CDATA[在__all__中引用未定义的变量名称时使用。]]>
</description>
</rule>
<rule>
<key>E0604</key>
<name><![CDATA[__all__中的无效对象%r，只能包含字符串]]></name>
<configKey>E0604</configKey>
<description>
<![CDATA[__all__中出现无效（非字符串）对象时使用。]]>
</description>
</rule>
<rule>
<key>E0611</key>
<name><![CDATA[模块%r中没有名称%r]]></name>
<configKey>E0611</configKey>
<description>
<![CDATA[在模块中找不到名称时使用。]]>
</description>
</rule>
<rule>
<key>E0633</key>
<name><![CDATA[尝试解开非序列%s]]></name>
<configKey>E0633</configKey>
<description>
<![CDATA[在解包分配中使用非序列的内容时使用]]>
</description>
</rule>
<rule>
<key>E0701</key>
<name><![CDATA[错误的except字句顺序(%s)]]></name>
<configKey>E0701</configKey>
<description>
<![CDATA[当except子句的顺序不正确（从更具体到更一般）时使用。如果不修复顺序，则最特定的处理程序可能无法捕获某些异常。]]>
</description>
</rule>
<rule>
<key>E0702</key>
<name><![CDATA[在仅允许类或实例的情况下提高%s]]></name>
<configKey>E0702</configKey>
<description>
<![CDATA[在引发非类、非实例或非字符串的对象时使用(即：将引发`TypeError`)。]]>
</description>
</rule>
<rule>
<key>E0703</key>
<name><![CDATA[异常上下文设置为非异常或无异常的内容]]></name>
<configKey>E0703</configKey>
<description>
<![CDATA[在使用语法"raise ... from ..."是使用，其中异常上下文设置为非异常或无异常的内容。]]>
</description>
</rule>
<rule>
<key>E0704</key>
<name><![CDATA[引发语句不在except子句中]]></name>
<configKey>E0704</configKey>
<description>
<![CDATA[当except子句中未使用空raise时使用。这会产生一个错误，因为没有活动的异常要重新引发。只要在try块内引发异常，此规则的异常就可以通过finally子句中的空raise来表示，该异常就可以工作，但它仍然是一种不可依赖的代码异味。]]>
</description>
</rule>
<rule>
<key>E0710</key>
<name><![CDATA[引发一个不继承自BaseException的新样式类]]></name>
<configKey>E0710</configKey>
<description>
<![CDATA[当引发不继承自BaseException的新样式类时使用。]]>
</description>
</rule>
<rule>
<key>E0711</key>
<name><![CDATA[引发NotImplemented-应该引发NotImplementedError]]></name>
<configKey>E0711</configKey>
<description>
<![CDATA[在引发NotImplemented而不是NotImplementedError时使用]]>
</description>
</rule>
<rule>
<key>E0712</key>
<name><![CDATA[捕获不继承自异常: %s的异常]]></name>
<configKey>E0712</configKey>
<description>
<![CDATA[当不继承自Exception的类在except子句中用作异常时使用。]]>
</description>
</rule>
<rule>
<key>E1003</key>
<name><![CDATA[错误的第一个参数%r提供给了super()]]></name>
<configKey>E1003</configKey>
<description>
<![CDATA[当将当前类以外的另一个参数作为超级内置函数的第一个参数给出时使用。]]>
</description>
</rule>
<rule>
<key>E1101</key>
<name><![CDATA[%s %r没有%r个成员%s]]></name>
<configKey>E1101</configKey>
<description>
<![CDATA[当为不存在的成员访问变量时使用。]]>
</description>
</rule>
<rule>
<key>E1102</key>
<name><![CDATA[%s不可调用]]></name>
<configKey>E1102</configKey>
<description>
<![CDATA[当被调用的对象被推断为不可调用的对象时使用。]]>
</description>
</rule>
<rule>
<key>E1111</key>
<name><![CDATA[函数调用的分配结果，其中函数没有返回值]]></name>
<configKey>E1111</configKey>
<description>
<![CDATA[在对函数调用执行赋值但推断的函数不返回任何内容时使用。]]>
</description>
</rule>
<rule>
<key>E1120</key>
<name><![CDATA[%s调用中的参数%s没有值]]></name>
<configKey>E1120</configKey>
<description>
<![CDATA[当函数调用传递的参数太少时使用。]]>
</description>
</rule>
<rule>
<key>E1121</key>
<name><![CDATA[%s调用的位置参数过多]]></name>
<configKey>E1121</configKey>
<description>
<![CDATA[当函数调用传递太多位置参数时使用。]]>
</description>
</rule>
<rule>
<key>E1123</key>
<name><![CDATA[%s调用中出现意外的关键字参数%r]]></name>
<configKey>E1123</configKey>
<description>
<![CDATA[当函数调用传递与该函数的参数名称之一不对应的关键字参数时使用。]]>
</description>
</rule>
<rule>
<key>E1124</key>
<name><![CDATA[参数%r在%s调用中按位置和关键字传递]]></name>
<configKey>E1124</configKey>
<description>
<![CDATA[当函数调用会导致向函数参数分配多个值时使用，其中一个值来自位置参数，另一个值来自关键字参数。]]>
</description>
</rule>
<rule>
<key>E1125</key>
<name><![CDATA[%s调用中缺少必填关键字参数%r]]></name>
<configKey>E1125</configKey>
<description>
<![CDATA[当函数调用未传递强制性的仅关键字参数时使用。]]>
</description>
</rule>
<rule>
<key>E1126</key>
<name><![CDATA[序列索引不是具有__index__的int,slice或instance]]></name>
<configKey>E1126</configKey>
<description>
<![CDATA[当序列类型被无效类型索引时使用。有效类型是使用__index__方法的ints, slices, 和 objects。]]>
</description>
</rule>
<rule>
<key>E1127</key>
<name><![CDATA[Slice索引不是int, None, 或具有__index__的实例]]></name>
<configKey>E1127</configKey>
<description>
<![CDATA[当Slice索引不是整数, None, 或带有__index__方法的对象时使用。]]>
</description>
</rule>
<rule>
<key>E1128</key>
<name><![CDATA[分配函数调用的结果，该函数返回None]]></name>
<configKey>E1128</configKey>
<description>
<![CDATA[在函数调用上完成赋值但推断的函数仅返回None时使用。]]>
</description>
</rule>
<rule>
<key>E1129</key>
<name><![CDATA[上下文管理器'%s'未实现__enter__ and __exit__。]]></name>
<configKey>E1129</configKey>
<description>
<![CDATA[当with语句中的实例未实现上下文管理器协议(__enter__/__exit__)时使用。]]>
</description>
</rule>
<rule>
<key>E1130</key>
<name><![CDATA[]]></name>
<configKey>E1130</configKey>
<description>
<![CDATA[在不支持此类操作的对象上使用一元操作数时触发。]]>
</description>
</rule>
<rule>
<key>E1131</key>
<name><![CDATA[]]></name>
<configKey>E1131</configKey>
<description>
<![CDATA[当不支持两个操作数之间的二进制算术运算时触发。]]>
</description>
</rule>
<rule>
<key>E1132</key>
<name><![CDATA[在函数调用中获得了关键字参数%r的多个值]]></name>
<configKey>E1132</configKey>
<description>
<![CDATA[当一个函数调用获得一个关键字的多个值时发出。]]>
</description>
</rule>
<rule>
<key>E1133</key>
<name><![CDATA[不可迭代的值%s用于迭代上下文]]></name>
<configKey>E1133</configKey>
<description>
<![CDATA[当在预期可迭代的地方使用不可迭代的值时使用]]>
</description>
</rule>
<rule>
<key>E1134</key>
<name><![CDATA[非映射值%s用于映射上下文]]></name>
<configKey>E1134</configKey>
<description>
<![CDATA[在需要映射的地方使用非映射值时使用]]>
</description>
</rule>
<rule>
<key>E1135</key>
<name><![CDATA[值'%s'不支持membership测试]]></name>
<configKey>E1135</configKey>
<description>
<![CDATA[当membership测试表达式中的实例未实现membership协议(__contains__/__iter__/__getitem__)时发出。]]>
</description>
</rule>
<rule>
<key>E1136</key>
<name><![CDATA[值'%s'不可取消]]></name>
<configKey>E1136</configKey>
<description>
<![CDATA[当下标的值不支持预订时发出（即未定义__getitem__方法）。]]>
</description>
</rule>
<rule>
<key>E1137</key>
<name><![CDATA[%r不支持项目分配]]></name>
<configKey>E1137</configKey>
<description>
<![CDATA[当对象不支持项目分配时发出（即未定义__setitem__方法）。]]>
</description>
</rule>
<rule>
<key>E1138</key>
<name><![CDATA[%r不支持删除项目]]></name>
<configKey>E1138</configKey>
<description>
<![CDATA[当对象不支持项目删除（即未定义__delitem__方法）时触发。]]>
</description>
</rule>
<rule>
<key>E1139</key>
<name><![CDATA[使用了无效的metaclass %r]]></name>
<configKey>E1139</configKey>
<description>
<![CDATA[当检测到一个类正在使用某类metaclass类，但是将其用作metaclass类可能是无效的时候，就发出该信息。]]>
</description>
</rule>
<rule>
<key>E1140</key>
<name><![CDATA[Dict键无法散列]]></name>
<configKey>E1140</configKey>
<description>
<![CDATA[当dict键不可散列时发出（即未定义__hash__方法）。]]>
</description>
</rule>
<rule>
<key>E1200</key>
<name><![CDATA[索引%d处不支持的logging格式字符%r(%#02x)]]></name>
<configKey>E1200</configKey>
<description>
<![CDATA[在logging语句格式字符串中使用了不受支持的格式字符时使用。]]>
</description>
</rule>
<rule>
<key>E1201</key>
<name><![CDATA[logging格式字符串在转换说明符的中间结束]]></name>
<configKey>E1201</configKey>
<description>
<![CDATA[当logging语句格式字符串在转换说明符的结尾之前终止时使用。]]>
</description>
</rule>
<rule>
<key>E1205</key>
<name><![CDATA[logging格式字符串的参数过多]]></name>
<configKey>E1205</configKey>
<description>
<![CDATA[给logging格式字符串提供太多参数时使用。]]>
</description>
</rule>
<rule>
<key>E1206</key>
<name><![CDATA[logging格式字符串参数不足]]></name>
<configKey>E1206</configKey>
<description>
<![CDATA[当logging格式字符串的参数太少时使用。]]>
</description>
</rule>
<rule>
<key>E1300</key>
<name><![CDATA[索引%d处不支持的格式字符%r(%#02x)]]></name>
<configKey>E1300</configKey>
<description>
<![CDATA[在格式字符串中使用不受支持的格式字符时使用。]]>
</description>
</rule>
<rule>
<key>E1301</key>
<name><![CDATA[格式字符串在转换说明符的中间结束]]></name>
<configKey>E1301</configKey>
<description>
<![CDATA[当格式字符串在转换说明符的结尾之前终止时使用。]]>
</description>
</rule>
<rule>
<key>E1302</key>
<name><![CDATA[在格式字符串中混合已命名和未命名的转换说明符]]></name>
<configKey>E1302</configKey>
<description>
<![CDATA[当格式化字符串同时包含命名的(例如'%(foo)d')和未命名的(例如'%d')转换说明符时使用。当指定的转换说明符包含*表示最小字段宽度和/或精度时，也可以使用此选项。]]>
</description>
</rule>
<rule>
<key>E1303</key>
<name><![CDATA[格式字符串的预期映射，而不是%s]]></name>
<configKey>E1303</configKey>
<description>
<![CDATA[当使用命名转换说明符的格式字符串与非映射参数一起使用时使用。]]>
</description>
</rule>
<rule>
<key>E1304</key>
<name><![CDATA[格式字符串字典中缺少键%r]]></name>
<configKey>E1304</configKey>
<description>
<![CDATA[当使用命名转换说明符的格式字符串与不包含格式字符串所需的所有键的字典一起使用时使用。]]>
</description>
</rule>
<rule>
<key>E1305</key>
<name><![CDATA[格式字符串的参数过多]]></name>
<configKey>E1305</configKey>
<description>
<![CDATA[当给使用未命名的转换说明符的格式字符串提供过多参数时使用。]]>
</description>
</rule>
<rule>
<key>E1306</key>
<name><![CDATA[格式字符串的参数不足]]></name>
<configKey>E1306</configKey>
<description>
<![CDATA[当给使用未命名的转换说明符的格式字符串提供过少参数时使用。]]>
</description>
</rule>
<rule>
<key>E1307</key>
<name><![CDATA[参数%r与格式类型%r不匹配]]></name>
<configKey>E1307</configKey>
<description>
<![CDATA[当格式字符串所需的类型不适合实际参数类型时使用]]>
</description>
</rule>
<rule>
<key>E1310</key>
<name><![CDATA[在%s.%s调用中有可疑参数]]></name>
<configKey>E1310</configKey>
<description>
<![CDATA[str.{l,r,}strip的参数调用包含重复字符]]>
</description>
</rule>
<rule>
<key>E1507</key>
<name><![CDATA[%s不支持%s类型参数]]></name>
<configKey>E1507</configKey>
<description>
<![CDATA[Env操作函数仅支持字符串类型参数。请参阅https://docs.python.org/3/library/os.html#os.getenv.]]>
</description>
</rule>
<rule>
<key>E1601</key>
<name><![CDATA[使用的print声明]]></name>
<configKey>E1601</configKey>
<description>
<![CDATA[在使用print语句时使用（`print`是Python 3中的函数）]]>
</description>
</rule>
<rule>
<key>E1602</key>
<name><![CDATA[指定的参数解包]]></name>
<configKey>E1602</configKey>
<description>
<![CDATA[为函数指定参数解包时使用（Python 3不允许使用）]]>
</description>
</rule>
<rule>
<key>E1603</key>
<name><![CDATA[Python 3不支持隐式解包异常]]></name>
<configKey>E1603</configKey>
<description>
<![CDATA[Python3不允许在except子句异常中隐式解包。请参阅http://www.python.org/dev/peps/pep-3110/]]>
</description>
</rule>
<rule>
<key>E1604</key>
<name><![CDATA[使用raise ErrorClass(args)而不是raise ErrorClass, args。]]></name>
<configKey>E1604</configKey>
<description>
<![CDATA[当使用替代的raise语法'raise foo, bar'而不是'raise foo(bar)'时使用。]]>
</description>
</rule>
<rule>
<key>E1605</key>
<name><![CDATA[``运算符的使用]]></name>
<configKey>E1605</configKey>
<description>
<![CDATA[当使用不推荐使用的"``"（反引号）运算符代替str()函数时使用。]]>
</description>
</rule>
<rule>
<key>E1700</key>
<name><![CDATA[内部异步函数的Yield]]></name>
<configKey>E1700</configKey>
<description>
<![CDATA[在异步函数中找到`yield`或`yield from`语句时使用。当使用小于3.5的Python版本时无法发出此消息。]]>
</description>
</rule>
<rule>
<key>E1701</key>
<name><![CDATA[异步上下文管理器'%s'没有实现__aenter__和__aexit__。]]></name>
<configKey>E1701</configKey>
<description>
<![CDATA[当异步上下文管理器与未实现异步上下文管理协议的对象一起使用时使用。当使用小于3.5的Python版本时无法发出此消息。]]>
</description>
</rule>
<rule>
<key>F0001</key>
<name><![CDATA[]]></name>
<configKey>F0001</configKey>
<description>
<![CDATA[当发生阻止分析模块的错误（例如找不到）时使用。]]>
</description>
</rule>
<rule>
<key>F0002</key>
<name><![CDATA[%s: %s]]></name>
<configKey>F0002</configKey>
<description>
<![CDATA[在构建Astroid表示形式时发生意外错误时使用。这通常伴随着回溯。请报告此类错误！]]>
</description>
</rule>
<rule>
<key>F0010</key>
<name><![CDATA[代码解析时出错：%s]]></name>
<configKey>F0010</configKey>
<description>
<![CDATA[当在构建可由Astroid处理的Astroid representation时发生异常时使用。]]>
</description>
</rule>
<rule>
<key>F0202</key>
<name><![CDATA[无法检查方法签名(%s / %s)]]></name>
<configKey>F0202</configKey>
<description>
<![CDATA[当Pylint由于意外原因无法检查方法签名兼容性时使用。如果您不了解，请报告这种情况。]]>
</description>
</rule>
<rule>
<key>I0001</key>
<name><![CDATA[无法在内置模块%s上运行原始检查程序]]></name>
<configKey>I0001</configKey>
<description>
<![CDATA[用于通知未使用原始检查程序检查内置模块。]]>
</description>
</rule>
<rule>
<key>I0010</key>
<name><![CDATA[无法考虑内联选项%r]]></name>
<configKey>I0010</configKey>
<description>
<![CDATA[内联选项格式错误或无法在模块内部使用内联选项时使用。]]>
</description>
</rule>
<rule>
<key>I0011</key>
<name><![CDATA[在本地禁用%s (%s)]]></name>
<configKey>I0011</configKey>
<description>
<![CDATA[在内联选项禁用消息或消息类别时使用。]]>
</description>
</rule>
<rule>
<key>I0013</key>
<name><![CDATA[忽略整个文件]]></name>
<configKey>I0013</configKey>
<description>
<![CDATA[用于通知文件将不被检查]]>
</description>
</rule>
<rule>
<key>I0020</key>
<name><![CDATA[禁止%s（来自%d行）]]></name>
<configKey>I0020</configKey>
<description>
<![CDATA[一条消息在一行上被触发，但是被文件中的disable= comment显式禁止。对于由于配置设置而被忽略的消息，不会生成此消息。]]>
</description>
</rule>
<rule>
<key>I0021</key>
<name><![CDATA[无用的%s禁止]]></name>
<configKey>I0021</configKey>
<description>
<![CDATA[当为一行或一段代码明确禁用消息但从未触发消息时报告。]]>
</description>
</rule>
<rule>
<key>I0022</key>
<name><![CDATA[语法"%s"已弃用，请改用"%s"]]></name>
<configKey>I0022</configKey>
<description>
<![CDATA[某些内联pylint选项已被重命名或重新设计，仅应使用最新形式。 注意：全部跳过仅适用于pylint >= 0.26]]>
</description>
</rule>
<rule>
<key>I0023</key>
<name><![CDATA[]]></name>
<configKey>I0023</configKey>
<description>
<![CDATA[通过ID启用或禁用消息时使用。]]>
</description>
</rule>
<rule>
<key>I1101</key>
<name><![CDATA[%s %r没有%r个成员%s，但源不可用。如果要基于活动对象的运行时自检来执行分析，请考虑将此模块添加到extension-pkg-whitelist中。]]></name>
<configKey>I1101</configKey>
<description>
<![CDATA[当访问不存在的C扩展成员变量时使用。 由于无法使用源，因此无法进行静态分析，但是可以通过在运行时自检活动对象来执行。]]>
</description>
</rule>
<rule>
<key>R0123</key>
<name><![CDATA[与文本的比较]]></name>
<configKey>R0123</configKey>
<description>
<![CDATA[将对象与文本进行比较时使用，通常这是您不希望执行的操作，因为您可以将对象与预期的文本进行比较。]]>
</description>
</rule>
<rule>
<key>R0124</key>
<name><![CDATA[冗余比较 - %s]]></name>
<configKey>R0124</configKey>
<description>
<![CDATA[当某项与自身进行比较时使用。]]>
</description>
</rule>
<rule>
<key>R0201</key>
<name><![CDATA[方法可能是一个函数]]></name>
<configKey>R0201</configKey>
<description>
<![CDATA[当方法不使用其绑定实例时使用，而且因此可以作为函数编写。]]>
</description>
</rule>
<rule>
<key>R0202</key>
<name><![CDATA[考虑使用decorator而不是调用类方法]]></name>
<configKey>R0202</configKey>
<description>
<![CDATA[在不使用decorator语法定义类方法时使用。]]>
</description>
</rule>
<rule>
<key>R0203</key>
<name><![CDATA[考虑使用decorator而不是调用staticmethod]]></name>
<configKey>R0203</configKey>
<description>
<![CDATA[在不使用decorator语法定义静态方法时使用。]]>
</description>
</rule>
<rule>
<key>R0205</key>
<name><![CDATA[类%r从object继承，可以从python3中的基类安全删除]]></name>
<configKey>R0205</configKey>
<description>
<![CDATA[当类从object继承时使用，在python3下该对象是隐式的，因此可以安全地从基类中删除。]]>
</description>
</rule>
<rule>
<key>R0401</key>
<name><![CDATA[循环导入(%s)]]></name>
<configKey>R0401</configKey>
<description>
<![CDATA[当检测到两个或多个模块之间的循环导入时使用。]]>
</description>
</rule>
<rule>
<key>R0801</key>
<name><![CDATA[%s文件中的类似行]]></name>
<configKey>R0801</configKey>
<description>
<![CDATA[表示已在多个文件中检测到一组相似的行。这通常意味着应重构代码以避免这种重复。]]>
</description>
</rule>
<rule>
<key>R0901</key>
<name><![CDATA[祖先太多(%s/%s)]]></name>
<configKey>R0901</configKey>
<description>
<![CDATA[当类的父类太多时使用，请尝试减少该类以获得更简单（并且因此更易于使用）的类。]]>
</description>
</rule>
<rule>
<key>R0902</key>
<name><![CDATA[实例属性过多(%s/%s)]]></name>
<configKey>R0902</configKey>
<description>
<![CDATA[在类具有太多实例属性的情况下使用，请尝试减少此属性以获得更简单（并且因此更易于使用）的类。]]>
</description>
</rule>
<rule>
<key>R0903</key>
<name><![CDATA[公共方法(%s/%s)太少]]></name>
<configKey>R0903</configKey>
<description>
<![CDATA[当类的公共方法太少时使用，因此请确保它确实值得使用。]]>
</description>
</rule>
<rule>
<key>R0904</key>
<name><![CDATA[公共方法(%s/%s)太多]]></name>
<configKey>R0904</configKey>
<description>
<![CDATA[当类具有太多公共方法时使用，请尝试减少此方法以获得更简单（因此更易于使用）的类。]]>
</description>
</rule>
<rule>
<key>R0911</key>
<name><![CDATA[返回语句(%s/%s)过多]]></name>
<configKey>R0911</configKey>
<description>
<![CDATA[当函数或方法的return语句过多，难以执行时使用。]]>
</description>
</rule>
<rule>
<key>R0912</key>
<name><![CDATA[分支结构(%s/%s)过多]]></name>
<configKey>R0912</configKey>
<description>
<![CDATA[当函数或方法的分支过多时，难以执行时使用。]]>
</description>
</rule>
<rule>
<key>R0913</key>
<name><![CDATA[参数(%s/%s)过多]]></name>
<configKey>R0913</configKey>
<description>
<![CDATA[当函数或方法具有太多参数时使用。]]>
</description>
</rule>
<rule>
<key>R0914</key>
<name><![CDATA[局部变量(%s/%s)过多]]></name>
<configKey>R0914</configKey>
<description>
<![CDATA[当函数或方法的局部变量过多时使用。]]>
</description>
</rule>
<rule>
<key>R0915</key>
<name><![CDATA[语句(%s/%s)过多]]></name>
<configKey>R0915</configKey>
<description>
<![CDATA[当函数或方法的语句过多时使用。然后，应将其拆分为较小的函数/方法。]]>
</description>
</rule>
<rule>
<key>R0916</key>
<name><![CDATA[if语句(%s/%s)中的布尔表达式过多]]></name>
<configKey>R0916</configKey>
<description>
<![CDATA[当if语句包含太多布尔表达式时使用。]]>
</description>
</rule>
<rule>
<key>R1701</key>
<name><![CDATA[考虑将这些isinstance调用合并到isinstance(%s, (%s))]]></name>
<configKey>R1701</configKey>
<description>
<![CDATA[可将多个连续的isinstance调用合并为一个时使用。]]>
</description>
</rule>
<rule>
<key>R1702</key>
<name><![CDATA[嵌套块(%s/%s)过多]]></name>
<configKey>R1702</configKey>
<description>
<![CDATA[当函数或方法具有太多嵌套块时使用。这使得代码难以理解和维护。]]>
</description>
</rule>
<rule>
<key>R1703</key>
<name><![CDATA[if语句可以替换为%s]]></name>
<configKey>R1703</configKey>
<description>
<![CDATA[当if语句可以用'bool(test)'替换时使用。]]>
</description>
</rule>
<rule>
<key>R1704</key>
<name><![CDATA[用本地名称%r重新定义参数]]></name>
<configKey>R1704</configKey>
<description>
<![CDATA[当本地名称正在重新定义参数时使用，这可能会提示潜在的错误。仅在少数名称绑定操作中考虑到这一点，例如带有语句赋值和异常处理程序赋值的迭代。]]>
</description>
</rule>
<rule>
<key>R1705</key>
<name><![CDATA["return"后不必要的"%s"]]></name>
<configKey>R1705</configKey>
<description>
<![CDATA[用于突出显示包含return语句的if语句后不必要的代码块。因此，当在一系列ifs后遇到else时，它将发出警告，所有ifs都包含一个return语句。]]>
</description>
</rule>
<rule>
<key>R1706</key>
<name><![CDATA[考虑使用三元(%s)]]></name>
<configKey>R1706</configKey>
<description>
<![CDATA[当使用已知的python 2.5之前版本的三元语法之一时使用。]]>
</description>
</rule>
<rule>
<key>R1707</key>
<name><![CDATA[不允许尾随逗号元组]]></name>
<configKey>R1707</configKey>
<description>
<![CDATA[在Python中，元组实际上是由逗号符号创建的，而不是由括号创建的。不幸的是，实际上可以通过错误地放置一个尾随逗号来创建元组，这可能会导致代码中潜在的奇怪错误。您应该始终显式地使用括号来创建元组。]]>
</description>
</rule>
<rule>
<key>R1708</key>
<name><![CDATA[不要在生成器中引发StopIteration，而是使用return语句]]></name>
<configKey>R1708</configKey>
<description>
<![CDATA[根据PEP479，提高StopIteration来结束生成器的循环可能会导致难以发现错误。 该PEP指定必须用简单的return语句替换raise StopIteration。]]>
</description>
</rule>
<rule>
<key>R1709</key>
<name><![CDATA[布尔表达式可以简化为%s]]></name>
<configKey>R1709</configKey>
<description>
<![CDATA[使用冗余的python 2.5之前版本的三元语法时发出。]]>
</description>
</rule>
<rule>
<key>R1710</key>
<name><![CDATA[函数中的所有return语句应返回一个表达式，或者都不返回。]]></name>
<configKey>R1710</configKey>
<description>
<![CDATA[根据PEP8，如果任何返回状态返回表达式，则不返回任何值的任何return语句应将其显式声明为return None，并且在函数末尾（如果可访问）应存在显式return语句]]>
</description>
</rule>
<rule>
<key>R1711</key>
<name><![CDATA[函数或方法结尾的无用返回]]></name>
<configKey>R1711</configKey>
<description>
<![CDATA[在函数或方法定义的末尾找到单个"return"或"return None"语句时触发。 可以安全删除该语句，因为Python会隐式返回None。"return" or "return None"]]>
</description>
</rule>
<rule>
<key>R1712</key>
<name><![CDATA[考虑使用tuple unpacking来交换变量]]></name>
<configKey>R1712</configKey>
<description>
<![CDATA[您不必使用临时变量来交换变量。使用"tuple unpacking"直接交换变量使意图更加明确。]]>
</description>
</rule>
<rule>
<key>R1713</key>
<name><![CDATA[考虑使用str.join(sequence)连接iterable中的字符串]]></name>
<configKey>R1713</configKey>
<description>
<![CDATA[与for循环迭代相比，使用str.join(sequence)更快，占用的内存更少，并且增加了可读性。]]>
</description>
</rule>
<rule>
<key>R1714</key>
<name><![CDATA[考虑将这些比较与"in"合并到%r]]></name>
<configKey>R1714</configKey>
<description>
<![CDATA[要检查某个变量是否等于多个值之一，请将这些值组合到一个元组中，然后检查该变量是否包含在其中，而不是检查每个值是否相等。这样既快捷又省时。]]>
</description>
</rule>
<rule>
<key>R1715</key>
<name><![CDATA[考虑使用dict.get从dict获取值（如果存在键）或默认值（如果不存在）]]></name>
<configKey>R1715</configKey>
<description>
<![CDATA[使用内置的dict.get从字典中获取值（如果存在键）或使用默认值（如果不存在键）则更简单，并且被认为更惯用，尽管有时会慢一些。]]>
</description>
</rule>
<rule>
<key>R1716</key>
<name><![CDATA[简化操作数之间的链式比较]]></name>
<configKey>R1716</configKey>
<description>
<![CDATA[当pylint遇到布尔运算（例如"a < b 和 b < c"）时，会发出此消息，建议改成"a < b < c"]]>
</description>
</rule>
<rule>
<key>R1717</key>
<name><![CDATA[考虑使用dictionary解析]]></name>
<configKey>R1717</configKey>
<description>
<![CDATA[尽管这段代码在语法上没有什么问题，但是它很难阅读并且可以简化为dict解析，而且速度更快，因为您不需要创建另一个临时列表。]]>
</description>
</rule>
<rule>
<key>R1718</key>
<name><![CDATA[考虑使用set解析]]></name>
<configKey>R1718</configKey>
<description>
<![CDATA[尽管这段代码在语法上没有什么问题，但是它很难阅读并且可以简化为set解析，而且速度更快，因为您不需要创建另一个临时列表。]]>
</description>
</rule>
<rule>
<key>R1719</key>
<name><![CDATA[if表达式可以替换为%s]]></name>
<configKey>R1719</configKey>
<description>
<![CDATA[当if表达式可以用'bool(test)'替换时使用。]]>
</description>
</rule>
<rule>
<key>R1720</key>
<name><![CDATA[在"raise"之后不必要的"%s"]]></name>
<configKey>R1720</configKey>
<description>
<![CDATA[用于突出显示包含raise语句的if后面不必要的代码块。因此，当遇到一个else跟随一个ifs链时，它将发出警告，所有ifs都包含一个raise语句。]]>
</description>
</rule>
<rule>
<key>W0101</key>
<name><![CDATA[无法访问的代码]]></name>
<configKey>W0101</configKey>
<description>
<![CDATA[在"return" 或 "raise" 语句后面有某些代码（永远无法访问）时使用。]]>
</description>
</rule>
<rule>
<key>W0102</key>
<name><![CDATA[危险的默认值%s作为参数]]></name>
<configKey>W0102</configKey>
<description>
<![CDATA[当在参数的默认值中检测到可变值作为列表或字典时使用。]]>
</description>
</rule>
<rule>
<key>W0104</key>
<name><![CDATA[声明似乎无效]]></name>
<configKey>W0104</configKey>
<description>
<![CDATA[在语句没有（或至少看起来）没有任何效果时使用。]]>
</description>
</rule>
<rule>
<key>W0105</key>
<name><![CDATA[字符串语句无效]]></name>
<configKey>W0105</configKey>
<description>
<![CDATA[当字符串用作语句时使用（这当然无效）。这是W0104的一个特殊情况，它有自己的消息，因此如果您将这些字符串用作文档而不是注释，则可以很轻松禁用它。]]>
</description>
</rule>
<rule>
<key>W0106</key>
<name><![CDATA[表达式"%s"未赋值]]></name>
<configKey>W0106</configKey>
<description>
<![CDATA[当不是函数调用的表达式被赋值为空时使用。可能是另有目的。]]>
</description>
</rule>
<rule>
<key>W0107</key>
<name><![CDATA[不必要的pass语句]]></name>
<configKey>W0107</configKey>
<description>
<![CDATA[在遇到可以避免的"pass"语句时使用。]]>
</description>
</rule>
<rule>
<key>W0108</key>
<name><![CDATA[Lambda可能不是必要的]]></name>
<configKey>W0108</configKey>
<description>
<![CDATA[当lambda表达式的主体是与lambda本身在相同参数列表上的函数调用时使用； 除了少数情况外，此类lambda表达式可全部替换为lambda主体中所调用的函数。]]>
</description>
</rule>
<rule>
<key>W0109</key>
<name><![CDATA[字典中的键%r重复]]></name>
<configKey>W0109</configKey>
<description>
<![CDATA[当字典表达式多次绑定相同的键时使用。]]>
</description>
</rule>
<rule>
<key>W0111</key>
<name><![CDATA[名称%s将成为Python %s中的关键字]]></name>
<configKey>W0111</configKey>
<description>
<![CDATA[在将来的Python版本中，由于引入了新关键字，赋值将变为无效时使用。]]>
</description>
</rule>
<rule>
<key>W0120</key>
<name><![CDATA[循环中不带break语句的else子句]]></name>
<configKey>W0120</configKey>
<description>
<![CDATA[如果循环可以使用break语句提前退出，循环仅应具有else子句，否则else下的语句应与循环本身处于相同的作用域。]]>
</description>
</rule>
<rule>
<key>W0122</key>
<name><![CDATA[exec的使用]]></name>
<configKey>W0122</configKey>
<description>
<![CDATA[在使用“ exec”语句（Python 3的函数）时使用，以阻止其使用。 这并不意味着您不能使用它！]]>
</description>
</rule>
<rule>
<key>W0123</key>
<name><![CDATA[eval的使用]]></name>
<configKey>W0123</configKey>
<description>
<![CDATA[在使用"eval"功能时使用，以阻止其使用。考虑使用`ast.literal_eval`安全评估包含来自不受信任来源的Python表达式的字符串。]]>
</description>
</rule>
<rule>
<key>W0124</key>
<name><![CDATA[在"as"之后跟随另一个上下文管理器看起来像一个元组。]]></name>
<configKey>W0124</configKey>
<description>
<![CDATA[当`with`语句组件返回多个值并仅对这些值的一部分使用`as`名称绑定时发出，如在使用ctx() as a, b 时一样。这可能会产生误导，因为尚不清楚上下文管理器是否返回元组，或者没有名称绑定的节点是否是另一个上下文管理器。]]>
</description>
</rule>
<rule>
<key>W0125</key>
<name><![CDATA[使用具有常量值的条件语句]]></name>
<configKey>W0125</configKey>
<description>
<![CDATA[当条件语句(If 或 ternary if)使用常量值进行测试时发出。这可能不是用户想要做的。]]>
</description>
</rule>
<rule>
<key>W0143</key>
<name><![CDATA[与可调用比较，是否省略了括号？]]></name>
<configKey>W0143</configKey>
<description>
<![CDATA[当pylint检测到与可调用对象进行了比较时，将发出此消息，这可能表明省略了一些括号，从而导致潜在的有害行为。]]>
</description>
</rule>
<rule>
<key>W0150</key>
<name><![CDATA[finally块中的%s语句可能会吞入异常]]></name>
<configKey>W0150</configKey>
<description>
<![CDATA[当在try ... finally块的finally子句中找到break或return语句时使用：try子句中引发的异常将被silently吞入，而不是重新引发。]]>
</description>
</rule>
<rule>
<key>W0199</key>
<name><![CDATA[Assert调用了2-uple。你的意思是 'assert x,y' 吗?]]></name>
<configKey>W0199</configKey>
<description>
<![CDATA[如果元组不为空，则对元组的assert调用将始终评估为true，如果为空，则将始终评估为false。]]>
</description>
</rule>
<rule>
<key>W0201</key>
<name><![CDATA[在__init__外部定义的属性%r]]></name>
<configKey>W0201</configKey>
<description>
<![CDATA[在__init__方法之外定义实例属性时使用。]]>
</description>
</rule>
<rule>
<key>W0211</key>
<name><![CDATA[以%r作为第一个参数的静态方法]]></name>
<configKey>W0211</configKey>
<description>
<![CDATA[当静态方法具有"self"或在valid- classmethod-first-arg 选项或 valid-metaclass-classmethod-first-arg 选项中指定的值作为第一个参数时使用。]]>
</description>
</rule>
<rule>
<key>W0212</key>
<name><![CDATA[访问客户端类的受保护成员%s]]></name>
<configKey>W0212</configKey>
<description>
<![CDATA[当受保护成员（即名称以下划线开头的类成员）在类外部或定义其的类的后代中访问时使用。]]>
</description>
</rule>
<rule>
<key>W0221</key>
<name><![CDATA[参数与%s%r方法不同]]></name>
<configKey>W0221</configKey>
<description>
<![CDATA[当方法的参数数量与已实现的接口或重写的方法中的参数数量不同时，使用此方法。]]>
</description>
</rule>
<rule>
<key>W0222</key>
<name><![CDATA[签名与%s%r方法不同]]></name>
<configKey>W0222</configKey>
<description>
<![CDATA[当方法签名不同于已实现的接口或重写的方法中时使用。]]>
</description>
</rule>
<rule>
<key>W0223</key>
<name><![CDATA[方法%r在类%r中是抽象的，但未被重写]]></name>
<configKey>W0223</configKey>
<description>
<![CDATA[在具体类中未覆盖抽象方法（即引发NotImplementedError）时使用。]]>
</description>
</rule>
<rule>
<key>W0231</key>
<name><![CDATA[未调用基类%r的__init__方法]]></name>
<configKey>W0231</configKey>
<description>
<![CDATA[当祖先类的方法具有__init__方法但派生类未调用该方法时使用。]]>
</description>
</rule>
<rule>
<key>W0232</key>
<name><![CDATA[类没有__init__方法]]></name>
<configKey>W0232</configKey>
<description>
<![CDATA[当类没有__init__方法，也没有其父类时使用。]]>
</description>
</rule>
<rule>
<key>W0233</key>
<name><![CDATA[调用来自非直接基类％r的__init__方法]]></name>
<configKey>W0233</configKey>
<description>
<![CDATA[当在不属于所分析类的直接祖先的类上调用__init__方法时使用。]]>
</description>
</rule>
<rule>
<key>W0235</key>
<name><![CDATA[方法%r中无用的超级委托]]></name>
<configKey>W0235</configKey>
<description>
<![CDATA[当我们可以检测到被重写的方法无用时使用，依赖super()委托来执行与MRO中的另一个方法相同的操作。]]>
</description>
</rule>
<rule>
<key>W0301</key>
<name><![CDATA[不必要的分号]]></name>
<configKey>W0301</configKey>
<description>
<![CDATA[当语句以分号(";")结尾时使用，分号不是必需的（这是python，不是C）。]]>
</description>
</rule>
<rule>
<key>W0311</key>
<name><![CDATA[缩进错误。找到%s %s，应为 %s]]></name>
<configKey>W0311</configKey>
<description>
<![CDATA[当发现意外数量的缩进制表符或空格时使用。]]>
</description>
</rule>
<rule>
<key>W0312</key>
<name><![CDATA[使用%ss而不是%ss找到缩进]]></name>
<configKey>W0312</configKey>
<description>
<![CDATA[当模块中有一些混合的制表符和空格时使用。]]>
</description>
</rule>
<rule>
<key>W0401</key>
<name><![CDATA[通配符导入%s]]></name>
<configKey>W0401</configKey>
<description>
<![CDATA[当检测到`from module import *`时使用。]]>
</description>
</rule>
<rule>
<key>W0402</key>
<name><![CDATA[已弃用模块%r的使用]]></name>
<configKey>W0402</configKey>
<description>
<![CDATA[已使用标记为已弃用的模块已导入。]]>
</description>
</rule>
<rule>
<key>W0404</key>
<name><![CDATA[重新导入%r（导入的行%s）]]></name>
<configKey>W0404</configKey>
<description>
<![CDATA[当模块被多次重新导入时使用。]]>
</description>
</rule>
<rule>
<key>W0406</key>
<name><![CDATA[模块导入本身]]></name>
<configKey>W0406</configKey>
<description>
<![CDATA[在模块导入自身时使用。]]>
</description>
</rule>
<rule>
<key>W0410</key>
<name><![CDATA[__future__导入不是第一个非docstring语句]]></name>
<configKey>W0410</configKey>
<description>
<![CDATA[Python 2.5及更高版本要求__future__导入是模块中的第一个非docstring语句。]]>
</description>
</rule>
<rule>
<key>W0511</key>
<name><![CDATA[]]></name>
<configKey>W0511</configKey>
<description>
<![CDATA[当检测到警告提示为FIXME或XXX时使用。]]>
</description>
</rule>
<rule>
<key>W0601</key>
<name><![CDATA[全局变量%r在模块级别未定义]]></name>
<configKey>W0601</configKey>
<description>
<![CDATA[通过"global"语句定义变量，但未在模块作用域中定义该变量时使用。]]>
</description>
</rule>
<rule>
<key>W0602</key>
<name><![CDATA[对%r使用global，但未完成分配]]></name>
<configKey>W0602</configKey>
<description>
<![CDATA[当通过“global”语句定义变量但未对此变量进行赋值时使用。]]>
</description>
</rule>
<rule>
<key>W0603</key>
<name><![CDATA[使用全局语句]]></name>
<configKey>W0603</configKey>
<description>
<![CDATA[在使用"global"语句更新全局变量时使用。Pylint只是试图阻止这种用法。那并不意味着您不能使用它！]]>
</description>
</rule>
<rule>
<key>W0604</key>
<name><![CDATA[在模块级别使用全局语句]]></name>
<configKey>W0604</configKey>
<description>
<![CDATA[在模块级别使用 "global" 语句时使用，因为它无效]]>
</description>
</rule>
<rule>
<key>W0611</key>
<name><![CDATA[未使用的%s]]></name>
<configKey>W0611</configKey>
<description>
<![CDATA[当未使用导入的模块或变量时使用。]]>
</description>
</rule>
<rule>
<key>W0612</key>
<name><![CDATA[未使用的变量%r]]></name>
<configKey>W0612</configKey>
<description>
<![CDATA[定义变量但未使用时使用。]]>
</description>
</rule>
<rule>
<key>W0613</key>
<name><![CDATA[未使用的参数%r]]></name>
<configKey>W0613</configKey>
<description>
<![CDATA[不使用函数或方法参数时使用。]]>
</description>
</rule>
<rule>
<key>W0614</key>
<name><![CDATA[未使用的导入%s（来自通配符导入）]]></name>
<configKey>W0614</configKey>
<description>
<![CDATA[当未从`'from X import *'`样式导入中使用导入的模块或变量时使用。]]>
</description>
</rule>
<rule>
<key>W0621</key>
<name><![CDATA[从外部作用域（第%s行）重新定义名称%r]]></name>
<configKey>W0621</configKey>
<description>
<![CDATA[当变量名隐藏在外部作用域中定义的名称时使用。]]>
</description>
</rule>
<rule>
<key>W0622</key>
<name><![CDATA[重新定义内置%r]]></name>
<configKey>W0622</configKey>
<description>
<![CDATA[当变量或函数重写内置时使用。]]>
</description>
</rule>
<rule>
<key>W0623</key>
<name><![CDATA[在异常处理程序中从%s重新定义名称%r]]></name>
<configKey>W0623</configKey>
<description>
<![CDATA[当异常处理程序将异常分配给现有名称时使用]]>
</description>
</rule>
<rule>
<key>W0631</key>
<name><![CDATA[使用可能未定义的循环变量%r]]></name>
<configKey>W0631</configKey>
<description>
<![CDATA[在循环外使用循环变量（即，由for循环或列表解析式或生成器表达式定义）时使用。]]>
</description>
</rule>
<rule>
<key>W0632</key>
<name><![CDATA[序列为%s的可能不平衡元组解包：左侧有%d个标签，右侧有%d个值]]></name>
<configKey>W0632</configKey>
<description>
<![CDATA[在赋值中存在不平衡元组解包时使用]]>
</description>
</rule>
<rule>
<key>W0640</key>
<name><![CDATA[循环中定义的单元变量%s]]></name>
<configKey>W0640</configKey>
<description>
<![CDATA[闭包中使用的变量在循环中定义。 这将导致所有闭包对封闭变量使用相同的值。]]>
</description>
</rule>
<rule>
<key>W0641</key>
<name><![CDATA[可能未使用的变量%r]]></name>
<configKey>W0641</configKey>
<description>
<![CDATA[在定义变量但可能不使用时使用。这种可能性来自可能使用locals（）的事实，这可能会使用或不使用所述变量]]>
</description>
</rule>
<rule>
<key>W0642</key>
<name><![CDATA[方法中对%s的赋值无效]]></name>
<configKey>W0642</configKey>
<description>
<![CDATA[分别在实例或类方法中对self或cls的无效赋值。]]>
</description>
</rule>
<rule>
<key>W0702</key>
<name><![CDATA[未指定异常类型]]></name>
<configKey>W0702</configKey>
<description>
<![CDATA[当except子句未指定要捕获的异常类型时使用。]]>
</description>
</rule>
<rule>
<key>W0703</key>
<name><![CDATA[捕获过于一般的异常%s]]></name>
<configKey>W0703</configKey>
<description>
<![CDATA[当except捕捉到一个过于一般的异常时使用，可能会隐藏不相关的错误。]]>
</description>
</rule>
<rule>
<key>W0705</key>
<name><![CDATA[捕获先前捕获的异常类型%s]]></name>
<configKey>W0705</configKey>
<description>
<![CDATA[当except捕获previous处理程序已经捕获的类型时使用。]]>
</description>
</rule>
<rule>
<key>W0706</key>
<name><![CDATA[except处理程序立即引发]]></name>
<configKey>W0706</configKey>
<description>
<![CDATA[当except处理程序使用raise作为其第一或唯一运算符时使用。这是没有用的，因为它会立即引发异常。删除raise运算符或整个try-except-raise块！]]>
</description>
</rule>
<rule>
<key>W0711</key>
<name><![CDATA[捕获异常是二进制"%s"操作的结果]]></name>
<configKey>W0711</configKey>
<description>
<![CDATA[当捕获的异常的格式为"except A or B:"时使用。 如果打算捕获多个，则重写为"except (A, B):"]]>
</description>
</rule>
<rule>
<key>W0715</key>
<name><![CDATA[异常参数表明可能需要设置字符串格式]]></name>
<configKey>W0715</configKey>
<description>
<![CDATA[当向异常构造函数传递多个参数时使用，其中第一个参数是一个字符串文本，包含用于格式化的占位符]]>
</description>
</rule>
<rule>
<key>W0716</key>
<name><![CDATA[无效的异常操作. %s]]></name>
<configKey>W0716</configKey>
<description>
<![CDATA[对异常执行操作，但该操作对所讨论的异常无效时使用。通常在except处理程序中的异常之间执行二进制操作时发出。]]>
</description>
</rule>
<rule>
<key>W1113</key>
<name><![CDATA[%s函数的定义中的可变位置参数列表之前的关键字参数]]></name>
<configKey>W1113</configKey>
<description>
<![CDATA[在变量位置参数之前定义关键字参数时，如果使用关键字参数调用方法，则可能会为上述参数传递多个值。]]>
</description>
</rule>
<rule>
<key>W1201</key>
<name><![CDATA[指定字符串格式参数作为logging函数参数]]></name>
<configKey>W1201</configKey>
<description>
<![CDATA[当logging语句的调用形式为"logging.<logging method>(format_string % (format_args...))"时使用。此类调用应将字符串插值保留到日志方法本身，并写入"logging.<logging method>(format_string, format_args...)"，以便在不记录消息的情况下，程序可以避免产生插值成本。有关更多信息，请参见http://www.python.org/dev/peps/pep-0282/。]]>
</description>
</rule>
<rule>
<key>W1202</key>
<name><![CDATA[在logging函数中使用%格式，并将 % 参数作为参数传递]]></name>
<configKey>W1202</configKey>
<description>
<![CDATA[当logging语句的调用形式为"logging.<logging method>(format_string.format(format_args...))"时使用。这样的调用应改为使用 % 格式，但通过将 parameters 作为参数传递，将插值留给logging函数。]]>
</description>
</rule>
<rule>
<key>W1203</key>
<name><![CDATA[在logging函数中使用%格式，并将 % 参数作为参数传递]]></name>
<configKey>W1203</configKey>
<description>
<![CDATA[当logging语句的调用形式为"logging.method(f"..."))"时使用。这样的调用应改为使用 % 格式，但通过将 parameters 作为参数传递，将插值留给logging函数。]]>
</description>
</rule>
<rule>
<key>W1300</key>
<name><![CDATA[格式化字符串字典中键应为字符串，而不是%s]]></name>
<configKey>W1300</configKey>
<description>
<![CDATA[当使用命名转换说明符的格式化字符串与键不是全部是字符串的字典一起使用时使用。]]>
</description>
</rule>
<rule>
<key>W1301</key>
<name><![CDATA[格式化字符串字典中有未使用的键%r]]></name>
<configKey>W1301</configKey>
<description>
<![CDATA[当使用命名转换说明符的格式化字符串与包含格式化字符串不需要的键的字典一起使用时使用。]]>
</description>
</rule>
<rule>
<key>W1302</key>
<name><![CDATA[格式化字符串无效]]></name>
<configKey>W1302</configKey>
<description>
<![CDATA[当PEP 3101格式化字符串无效时使用。]]>
</description>
</rule>
<rule>
<key>W1303</key>
<name><![CDATA[格式化字符串缺少关键字参数%r]]></name>
<configKey>W1303</configKey>
<description>
<![CDATA[当使用命名字段的PEP 3101格式化字符串未收到一个或多个必需关键字时使用。]]>
</description>
</rule>
<rule>
<key>W1304</key>
<name><![CDATA[未使用的格式参数%r]]></name>
<configKey>W1304</configKey>
<description>
<![CDATA[当使用named字段的PEP 3101格式字符串与格式字符串不需要的参数一起使用时使用。]]>
</description>
</rule>
<rule>
<key>W1305</key>
<name><![CDATA[格式字符串包含自动字段编号和手动字段规定]]></name>
<configKey>W1305</configKey>
<description>
<![CDATA[当PEP 3101格式字符串同时包含自动字段编号 (如 '{}') 和手动字段规定 (如 '{0}').]]>
</description>
</rule>
<rule>
<key>W1306</key>
<name><![CDATA[格式说明符%r中缺少格式属性%r]]></name>
<configKey>W1306</configKey>
<description>
<![CDATA[当PEP 3101格式字符串使用属性说明符({0.length})，但传递用于格式化的参数没有该属性时使用。]]>
</description>
</rule>
<rule>
<key>W1307</key>
<name><![CDATA[在格式说明符%r中使用无效的查找键%r]]></name>
<configKey>W1307</configKey>
<description>
<![CDATA[当PEP 3101格式字符串使用查找说明符({a[1]})，但传递用于格式化的参数不包含或没有该键作为属性时使用。]]>
</description>
</rule>
<rule>
<key>W1308</key>
<name><![CDATA[字符串格式参数%r重复，请考虑将其作为named参数传递]]></name>
<configKey>W1308</configKey>
<description>
<![CDATA[当我们检测到字符串格式正在重复一个参数而不是使用named字符串参数时使用]]>
</description>
</rule>
<rule>
<key>W1401</key>
<name><![CDATA[字符串中的反斜杠异常：“%s”。字符串常量可能缺少r前缀。]]></name>
<configKey>W1401</configKey>
<description>
<![CDATA[当反斜杠在文字字符串中但不用作转义符时使用。]]>
</description>
</rule>
<rule>
<key>W1402</key>
<name><![CDATA[字节字符串中的Unicode异常转义：'%s'。字符串常量可能缺少r或u前缀。]]></name>
<configKey>W1402</configKey>
<description>
<![CDATA[在字节串中遇到像\u这样的转义符无效时使用。]]>
</description>
</rule>
<rule>
<key>W1403</key>
<name><![CDATA[在%s中发现隐式字符串连接]]></name>
<configKey>W1403</configKey>
<description>
<![CDATA[字符串文本在文本可迭代的定义中隐式连接：可能缺少逗号？]]>
</description>
</rule>
<rule>
<key>W1501</key>
<name><![CDATA["%s"不是打开的有效模式。]]></name>
<configKey>W1501</configKey>
<description>
<![CDATA[Python支持：带有 b, +, and U (仅带有 r)选项的r, w, a[, x] 模式。参见 http://docs.python.org/2/library/functions.html#open]]>
</description>
</rule>
<rule>
<key>W1503</key>
<name><![CDATA[重复使用常数值为％r的％s]]></name>
<configKey>W1503</configKey>
<description>
<![CDATA[assertTrue和assertFalse的第一个参数是一个条件。 如果将常量作为参数传递，则该条件将始终为true。 在这种情况下，应该发出警告。]]>
</description>
</rule>
<rule>
<key>W1505</key>
<name><![CDATA[使用不推荐的方法%s()]]></name>
<configKey>W1505</configKey>
<description>
<![CDATA[该方法被标记为已弃用，并将在将来的Python版本中删除。考虑在文档中寻找替代方法。]]>
</description>
</rule>
<rule>
<key>W1506</key>
<name><![CDATA[threading.Thread需要目标函数]]></name>
<configKey>W1506</configKey>
<description>
<![CDATA[在未传递目标函数的情况下实例化threading.Thread类时发出警告。默认情况下，第一个参数是组参数，而不是目标参数。]]>
</description>
</rule>
<rule>
<key>W1507</key>
<name><![CDATA[使用copy.copy(os.environ)。请改用os.environ.copy() 。]]></name>
<configKey>W1507</configKey>
<description>
<![CDATA[os.environ不是dict对象，而是代理对象，所以浅拷贝仍然对原始对象有影响。参见 https://bugs.python.org/issue15373 for reference.]]>
</description>
</rule>
<rule>
<key>W1508</key>
<name><![CDATA[%s默认类型是%s。应为str 或 None。]]></name>
<configKey>W1508</configKey>
<description>
<![CDATA[Env操作函数返回None或str值。默认提供任何其他内容都可能导致错误。参见https://docs.python.org/3/library/os.html#os.getenv.]]>
</description>
</rule>
<rule>
<key>W1509</key>
<name><![CDATA[使用preexec_fn关键字，该关键字在存在线程的情况下可能不安全]]></name>
<configKey>W1509</configKey>
<description>
<![CDATA[preexec_fn参数在应用程序中存在线程时使用是不安全的。在调用exec之前，子进程可能会死锁。如果您必须使用它，请保持它的琐碎！最小化您要调用的库的数量。https://docs.python.org/3/library/subprocess.html#popen-constructor]]>
</description>
</rule>
<rule>
<key>W1601</key>
<name><![CDATA[apply内置引用]]></name>
<configKey>W1601</configKey>
<description>
<![CDATA[在引用apply内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1602</key>
<name><![CDATA[basestring内置引用]]></name>
<configKey>W1602</configKey>
<description>
<![CDATA[在引用basestring内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1603</key>
<name><![CDATA[buffer内置引用]]></name>
<configKey>W1603</configKey>
<description>
<![CDATA[在引用buffer内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1604</key>
<name><![CDATA[cmp内置引用]]></name>
<configKey>W1604</configKey>
<description>
<![CDATA[在引用cmp内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1605</key>
<name><![CDATA[coerce内置引用]]></name>
<configKey>W1605</configKey>
<description>
<![CDATA[在引用coerce内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1606</key>
<name><![CDATA[execfile内置引用]]></name>
<configKey>W1606</configKey>
<description>
<![CDATA[在引用execfile内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1607</key>
<name><![CDATA[file内置引用]]></name>
<configKey>W1607</configKey>
<description>
<![CDATA[在引用file内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1608</key>
<name><![CDATA[long内置引用]]></name>
<configKey>W1608</configKey>
<description>
<![CDATA[在引用long内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1609</key>
<name><![CDATA[raw_input内置引用]]></name>
<configKey>W1609</configKey>
<description>
<![CDATA[在引用raw_input内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1610</key>
<name><![CDATA[reduce内置引用]]></name>
<configKey>W1610</configKey>
<description>
<![CDATA[在引用reduce内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1611</key>
<name><![CDATA[StandardError内置引用]]></name>
<configKey>W1611</configKey>
<description>
<![CDATA[在引用StandardError内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1612</key>
<name><![CDATA[unicode内置引用]]></name>
<configKey>W1612</configKey>
<description>
<![CDATA[在引用Unicode内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1613</key>
<name><![CDATA[xrange内置引用]]></name>
<configKey>W1613</configKey>
<description>
<![CDATA[在引用xrange内置函数时使用（Python 3缺少此函数）]]>
</description>
</rule>
<rule>
<key>W1614</key>
<name><![CDATA[定义__coerce__方法]]></name>
<configKey>W1614</configKey>
<description>
<![CDATA[在定义__coerce__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1615</key>
<name><![CDATA[定义__delslice__方法]]></name>
<configKey>W1615</configKey>
<description>
<![CDATA[在定义__delslice__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1616</key>
<name><![CDATA[定义__getslice__方法]]></name>
<configKey>W1616</configKey>
<description>
<![CDATA[在定义__getslice__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1617</key>
<name><![CDATA[定义__setslice__方法]]></name>
<configKey>W1617</configKey>
<description>
<![CDATA[在定义__setslice__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1618</key>
<name><![CDATA[导入缺失 `from __future__ import absolute_import`]]></name>
<configKey>W1618</configKey>
<description>
<![CDATA[当导入不伴有``from __future__ import absolute_import`` 时使用(Python 3中的默认行为)]]>
</description>
</rule>
<rule>
<key>W1619</key>
<name><![CDATA[使用精准除法没有使用__future__语句]]></name>
<configKey>W1619</configKey>
<description>
<![CDATA[当没有使用floor语句的除法没有使用浮点型字符或者没有``from __future__ import division`` 时使用(Python 3无条件返回int除法的浮点数)]]>
</description>
</rule>
<rule>
<key>W1620</key>
<name><![CDATA[调用dict.iter*()方法]]></name>
<configKey>W1620</configKey>
<description>
<![CDATA[用于对dict.iterkeys(), itervalues() 或 iteritems() 的调用（Python 3缺少这些方法）]]>
</description>
</rule>
<rule>
<key>W1621</key>
<name><![CDATA[调用dict.view *()方法]]></name>
<configKey>W1621</configKey>
<description>
<![CDATA[用于调用dict.viewkeys(), viewvalues() 或 viewitems() (Python 3 缺少这些方法)]]>
</description>
</rule>
<rule>
<key>W1622</key>
<name><![CDATA[在对象上调用了next()方法]]></name>
<configKey>W1622</configKey>
<description>
<![CDATA[在调用对象的next()方法时使用（Python 3使用next()内置函数）]]>
</description>
</rule>
<rule>
<key>W1623</key>
<name><![CDATA[分配给类的__metaclass__属性]]></name>
<configKey>W1623</configKey>
<description>
<![CDATA[通过分配给__metaclass__来指定元类时使用（Python 3将元类指定为类声明参数）]]>
</description>
</rule>
<rule>
<key>W1624</key>
<name><![CDATA[索引异常不适用于Python 3。]]></name>
<configKey>W1624</configKey>
<description>
<![CDATA[索引异常不适用于Python3。请改用`exception.args[index]`。]]>
</description>
</rule>
<rule>
<key>W1625</key>
<name><![CDATA[引发字符串异常]]></name>
<configKey>W1625</configKey>
<description>
<![CDATA[引发字符串异常时使用。 这不适用于Python 3。]]>
</description>
</rule>
<rule>
<key>W1626</key>
<name><![CDATA[reload内置引用]]></name>
<configKey>W1626</configKey>
<description>
<![CDATA[在引用内置reload函数时使用（Python3缺少此函数）。您可以改用imp.reload或importlib.reload。]]>
</description>
</rule>
<rule>
<key>W1627</key>
<name><![CDATA[定义__oct__方法]]></name>
<configKey>W1627</configKey>
<description>
<![CDATA[在定义__oct__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1628</key>
<name><![CDATA[定义__hex__方法]]></name>
<configKey>W1628</configKey>
<description>
<![CDATA[在定义__hex__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1629</key>
<name><![CDATA[定义__nonzero__方法]]></name>
<configKey>W1629</configKey>
<description>
<![CDATA[在定义__nonzero__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1630</key>
<name><![CDATA[定义__cmp__方法]]></name>
<configKey>W1630</configKey>
<description>
<![CDATA[在定义__cmp__方法时使用（Python 3不使用该方法）]]>
</description>
</rule>
<rule>
<key>W1632</key>
<name><![CDATA[input内置引用]]></name>
<configKey>W1632</configKey>
<description>
<![CDATA[在引用内置input时使用（Python 3中向后不兼容的语义）]]>
</description>
</rule>
<rule>
<key>W1633</key>
<name><![CDATA[round内置引用]]></name>
<configKey>W1633</configKey>
<description>
<![CDATA[在引用内置round函数时使用（Python 3中向后不兼容的语义）]]>
</description>
</rule>
<rule>
<key>W1634</key>
<name><![CDATA[intern内置引用]]></name>
<configKey>W1634</configKey>
<description>
<![CDATA[在引用内置intern时使用（在Python 3中移至sys.intern）]]>
</description>
</rule>
<rule>
<key>W1635</key>
<name><![CDATA[unichr内置引用]]></name>
<configKey>W1635</configKey>
<description>
<![CDATA[在引用unichr内置函数时使用（在Python 3中使用chr）]]>
</description>
</rule>
<rule>
<key>W1636</key>
<name><![CDATA[不迭代时引用的内置map]]></name>
<configKey>W1636</configKey>
<description>
<![CDATA[在非迭代上下文中引用内置map时使用（在Python时使用（在Python 3中返回迭代器）]]>
</description>
</rule>
<rule>
<key>W1637</key>
<name><![CDATA[未迭代时引用的内置zip]]></name>
<configKey>W1637</configKey>
<description>
<![CDATA[在非迭代上下文中引用内置的zip时使用（返回Python 3中的迭代器）]]>
</description>
</rule>
<rule>
<key>W1638</key>
<name><![CDATA[不迭代时引用的内置范围]]></name>
<configKey>W1638</configKey>
<description>
<![CDATA[在非迭代上下文中引用内置范围时使用（在Python 3中返回迭代器）]]>
</description>
</rule>
<rule>
<key>W1639</key>
<name><![CDATA[不迭代时引用的内置过滤器]]></name>
<configKey>W1639</configKey>
<description>
<![CDATA[在非迭代上下文中引用内置过滤器时使用（在Python 3中返回迭代器）]]>
</description>
</rule>
<rule>
<key>W1640</key>
<name><![CDATA[使用cmp参数进行list.sort /排序]]></name>
<configKey>W1640</configKey>
<description>
<![CDATA[应该避免将cmp参数用于list.sort或sorted内置函数，因为它已在Python 3中删除。应该首选使用`key`或`functools.cmp_to_key`。]]>
</description>
</rule>
<rule>
<key>W1641</key>
<name><![CDATA[在不同时实现__hash__的情况下实现__eq__]]></name>
<configKey>W1641</configKey>
<description>
<![CDATA[当类实现__eq__而不是__hash__时使用。在Python 2中，对象获取object.__hash__作为默认实现，在Python 3中，如果对象也实现__eq__，则将None作为其默认__hash__实现。]]>
</description>
</rule>
<rule>
<key>W1642</key>
<name><![CDATA[定义__div__方法]]></name>
<configKey>W1642</configKey>
<description>
<![CDATA[在定义__div__方法时使用。最好使用`__truediv__`并设置__div__ = __truediv__。(Python 3不使用该方法)]]>
</description>
</rule>
<rule>
<key>W1643</key>
<name><![CDATA[定义__idiv__方法]]></name>
<configKey>W1643</configKey>
<description>
<![CDATA[在定义__idiv__方法时使用。最好使用`__itruediv__`并设置__idiv__ = __itruediv__。(Python 3不使用该方法)]]>
</description>
</rule>
<rule>
<key>W1644</key>
<name><![CDATA[定义__rdiv__方法]]></name>
<configKey>W1644</configKey>
<description>
<![CDATA[在定义__rdiv__方法是使用。最好使用`__rtruediv__`并设置__rdiv__ = __rtruediv__。(Python 3不使用该方法)]]>
</description>
</rule>
<rule>
<key>W1645</key>
<name><![CDATA[在Python 3中删除了Exception.message]]></name>
<configKey>W1645</configKey>
<description>
<![CDATA[在异常上访问message属性时使用。请改用str(exception)。]]>
</description>
</rule>
<rule>
<key>W1646</key>
<name><![CDATA[str.decode中使用的非文本编码]]></name>
<configKey>W1646</configKey>
<description>
<![CDATA[使用str.encode或str.decode进行非文本编码时使用。使用编解码器模块处理任意编解码器。]]>
</description>
</rule>
<rule>
<key>W1647</key>
<name><![CDATA[在python 3中删除了sys.maxint]]></name>
<configKey>W1647</configKey>
<description>
<![CDATA[在访问sys.maxint时使用。请改用sys.maxsize。]]>
</description>
</rule>
<rule>
<key>W1649</key>
<name><![CDATA[访问字符串模块上不推荐使用的函数]]></name>
<configKey>W1649</configKey>
<description>
<![CDATA[在访问Python 3中已弃用的字符串函数时使用。]]>
</description>
</rule>
<rule>
<key>W1650</key>
<name><![CDATA[使用带有不推荐使用的deletechars参数的str.translate]]></name>
<configKey>W1650</configKey>
<description>
<![CDATA[在str.translate中使用不推荐使用的deletechars参数时使用。使用re.sub删除所需字符。]]>
</description>
</rule>
<rule>
<key>W1651</key>
<name><![CDATA[访问itertools模块上已弃用的函数]]></name>
<configKey>W1651</configKey>
<description>
<![CDATA[在访问已在Python 3中删除的itertools函数时使用。]]>
</description>
</rule>
<rule>
<key>W1652</key>
<name><![CDATA[访问类型模块上已弃用的字段]]></name>
<configKey>W1652</configKey>
<description>
<![CDATA[在访问已在Python 3中删除的类型的字段时使用。]]>
</description>
</rule>
<rule>
<key>W1653</key>
<name><![CDATA[next定义的方法]]></name>
<configKey>W1653</configKey>
<description>
<![CDATA[在定义了在Python 2中是迭代器但在Python 3中被视为普通函数的next方法时使用。]]>
</description>
</rule>
<rule>
<key>W1654</key>
<name><![CDATA[不迭代时引用的dict.items]]></name>
<configKey>W1654</configKey>
<description>
<![CDATA[在非迭代上下文中引用dict.items时使用（在Python 3中返回迭代器）]]>
</description>
</rule>
<rule>
<key>W1655</key>
<name><![CDATA[不迭代时引用的dict.keys]]></name>
<configKey>W1655</configKey>
<description>
<![CDATA[在非迭代上下文中引用dict.keys时使用（在Python 3中返回迭代器）]]>
</description>
</rule>
<rule>
<key>W1656</key>
<name><![CDATA[不迭代时引用的dict.values]]></name>
<configKey>W1656</configKey>
<description>
<![CDATA[在非迭代上下文中引用dict.values时使用（在Python 3中返回迭代器）]]>
</description>
</rule>
<rule>
<key>W1657</key>
<name><![CDATA[访问operator模块上已移除的属性]]></name>
<configKey>W1657</configKey>
<description>
<![CDATA[访问已在Python 3中删除的operator模块上的字段时使用。]]>
</description>
</rule>
<rule>
<key>W1658</key>
<name><![CDATA[访问urllib模块上的已删除属性]]></name>
<configKey>W1658</configKey>
<description>
<![CDATA[访问已在Python 3中移除或移动的urllib模块上的字段时使用。]]>
</description>
</rule>
<rule>
<key>W1659</key>
<name><![CDATA[访问已删除的xreadlines属性]]></name>
<configKey>W1659</configKey>
<description>
<![CDATA[在访问文件流上的xreadlines()函数时使用，已在Python 3中删除。]]>
</description>
</rule>
<rule>
<key>W1660</key>
<name><![CDATA[访问sys模块上的已删除属性]]></name>
<configKey>W1660</configKey>
<description>
<![CDATA[在访问已在Python 3中删除的sys模块上的字段时使用。]]>
</description>
</rule>
<rule>
<key>W1661</key>
<name><![CDATA[使用由except处理程序绑定的异常对象]]></name>
<configKey>W1661</configKey>
<description>
<![CDATA[使用异常时发出，该异常绑定在except处理程序之外的except处理程序中。在Python 3上，一旦这些异常脱离了except处理程序，它们将被删除。]]>
</description>
</rule>
<rule>
<key>W1662</key>
<name><![CDATA[使用绑定在解析（comprehension）内部的变量]]></name>
<configKey>W1662</configKey>
<description>
<![CDATA[当使用变量时，该变量在解析（comprehension）本身之外绑定在解析（comprehension）处理程序时发出。在Python 3上，这些变量将在comprehension范围之外删除。]]>
</description>
</rule>
</rules>
